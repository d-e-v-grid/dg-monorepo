### File: lua/register-heartbeat.lua
```
-- KEYS[1] - node key (hash)
-- KEYS[2] - heartbeat key (string)
-- KEYS[3] - nodes index set

-- ARGV[1] - node id
-- ARGV[2] - address
-- ARGV[3] - services (JSON)
-- ARGV[4] - timestamp
-- ARGV[5] - node TTL (seconds)
-- ARGV[6] - heartbeat TTL (milliseconds)

redis.call('HMSET', KEYS[1],
  'address', ARGV[2],
  'services', ARGV[3],
  'timestamp', ARGV[4]
)

redis.call('EXPIRE', KEYS[1], ARGV[5])
redis.call('PSETEX', KEYS[2], ARGV[6], '1')
redis.call('SADD', KEYS[3], ARGV[1])

return 1

```

### File: src/abstract-peer.ts
```
import semver from 'semver';

import { Netron } from './netron';
import { Interface } from './interface';
import { Definition } from './definition';
import { isServiceInterface } from './predicates';
import { Abilities, EventSubscriber } from './types';

/**
 * Abstract base class representing a peer in the Netron network.
 * Provides core functionality for service discovery, interface management,
 * and communication between peers.
 * 
 * @abstract
 */
export abstract class AbstractPeer {
  /**
   * Collection of abilities supported by this peer.
   * Abilities represent the capabilities and features that this peer can provide.
   */
  public abilities: Abilities = {};

  /**
   * Internal map storing interface instances and their reference counts.
   * Key is the definition ID, value contains the interface instance and its reference count.
   * Used for managing interface lifecycle and preventing memory leaks.
   */
  protected interfaces = new Map<string, { instance: Interface; refCount: number }>();

  /**
   * Constructs a new AbstractPeer instance.
   * 
   * @param {Netron} netron - The Netron instance this peer belongs to
   * @param {string} id - Unique identifier for this peer
   */
  constructor(
    public netron: Netron,
    public id: string
  ) { }

  /**
   * Sets a property value or calls a method on the remote peer.
   * 
   * @param {string} defId - Unique identifier of the definition context
   * @param {string} name - Name of the property or method
   * @param {any} value - Value to set or arguments for method call
   * @returns {Promise<void>} Resolves when operation completes
   * @abstract
   */
  abstract set(defId: string, name: string, value: any): Promise<void>;

  /**
   * Retrieves a property value or calls a method on the remote peer.
   * 
   * @param {string} defId - Unique identifier of the definition context
   * @param {string} name - Name of the property or method
   * @returns {Promise<any>} Resolves with the property value or method result
   * @abstract
   */
  abstract get(defId: string, name: string): Promise<any>;

  /**
   * Invokes a method on the remote peer with specified arguments.
   * 
   * @param {string} defId - Unique identifier of the definition context
   * @param {string} method - Name of the method to invoke
   * @param {any[]} args - Array of arguments to pass to the method
   * @returns {Promise<any>} Resolves with the method's return value
   * @abstract
   */
  abstract call(defId: string, method: string, args: any[]): Promise<any>;

  /**
   * Subscribes to an event emitted by the remote peer.
   * 
   * @param {string} eventName - Name of the event to subscribe to
   * @param {EventSubscriber} handler - Function to handle event notifications
   * @returns {Promise<void> | void} Resolves when subscription is complete
   * @abstract
   */
  abstract subscribe(eventName: string, handler: EventSubscriber): Promise<void> | void;

  /**
   * Unsubscribes from a previously subscribed event.
   * 
   * @param {string} eventName - Name of the event to unsubscribe from
   * @param {EventSubscriber} handler - Handler function to remove
   * @returns {Promise<void> | void} Resolves when unsubscription is complete
   * @abstract
   */
  abstract unsubscribe(eventName: string, handler: EventSubscriber): Promise<void> | void;

  /**
   * Exposes a service instance to be accessible by other peers.
   * 
   * @param {any} instance - The service instance to expose
   * @returns {Promise<Definition>} Resolves with the service definition
   * @abstract
   */
  abstract exposeService(instance: any): Promise<Definition>;

  /**
   * Removes a previously exposed service from accessibility.
   * 
   * @param {string} ctxId - Context identifier of the service to unexpose
   * @param {boolean} [releaseOriginated] - Whether to release originated services
   * @returns {Promise<void>} Resolves when service is unexposed
   * @abstract
   */
  abstract unexposeService(ctxId: string, releaseOriginated?: boolean): Promise<void>;

  /**
   * Removes all services exposed by this peer.
   * Iterates through all service names and unexposes each one.
   */
  unexposeAllServices() {
    for (const ctxId of this.getServiceNames()) {
      this.unexposeService(ctxId);
    }
  }

  /**
   * Retrieves names of all services currently exposed by this peer.
   * 
   * @returns {string[]} Array of service names
   * @abstract
   */
  abstract getServiceNames(): string[];

  /**
   * Queries and retrieves an interface for a specified service.
   * Handles version resolution and interface creation.
   * 
   * @template T - Type of the interface to return
   * @param {string} qualifiedName - Service name with optional version (name@version)
   * @returns {Promise<T>} Resolves with the requested interface instance
   */
  async queryInterface<T>(qualifiedName: string): Promise<T> {
    let name: string;
    let version: string | undefined;

    if (qualifiedName.includes('@')) {
      [name, version] = qualifiedName.split('@') as [string, string | undefined];
    } else {
      name = qualifiedName;
      version = '*';
    }

    let def: Definition;

    if (version === '*' || !version) {
      def = this.findLatestServiceVersion(name);
    } else {
      const exactKey = `${name}@${version}`;
      def = this.getDefinitionByServiceName(exactKey);
    }

    return this.queryInterfaceByDefId(def.id, def);
  }

  /**
   * Retrieves an interface instance by its definition ID.
   * Manages interface caching and reference counting.
   * 
   * @template T - Type of the interface to return
   * @param {string} defId - Definition ID of the interface
   * @param {Definition} [def] - Optional pre-fetched definition
   * @returns {T} The interface instance
   */
  queryInterfaceByDefId<T>(defId: string, def?: Definition): T {
    if (!def) {
      def = this.getDefinitionById(defId);
    }

    let iInfo = this.interfaces.get(defId);
    if (iInfo !== void 0) {
      iInfo.refCount++;
      return iInfo.instance as T;
    }

    const instance = Interface.create(def, this);
    iInfo = { instance, refCount: 1 };
    this.interfaces.set(def.id, iInfo);
    return instance as T;
  }

  /**
   * Releases a previously queried interface.
   * Handles reference counting and cleanup of dependent interfaces.
   * 
   * @template T - Type of the interface to release
   * @param {T} iInstance - Interface instance to release
   * @param {Set<string>} [released] - Set of already released definition IDs
   * @returns {Promise<void>} Resolves when interface is released
   * @throws {Error} If interface is invalid or not found
   */
  async releaseInterface<T>(iInstance: T, released = new Set<string>()) {
    if (!isServiceInterface(iInstance) || !iInstance.$def) {
      throw new Error('Invalid interface');
    }

    const defId = iInstance.$def.id;
    if (released.has(defId)) return;
    released.add(defId);

    const iInfo = this.interfaces.get(defId);
    if (!iInfo) {
      throw new Error('Invalid interface');
    }

    iInfo.refCount--;
    if (iInfo.refCount === 0) {
      this.interfaces.delete(defId);

      for (const i of this.interfaces.values()) {
        if (i.instance.$def?.parentId === defId) {
          this.releaseInterface(i.instance);
        }
      }

      await this.releaseInterfaceInternal(iInstance);
      iInstance.$def = undefined;
      iInstance.$peer = undefined;
    }
  }

  /**
   * Internal method to handle interface release.
   * 
   * @param {any} iInstance - Interface instance to release
   * @returns {Promise<void>} Resolves when internal release is complete
   * @abstract
   */
  protected abstract releaseInterfaceInternal(iInstance: any): Promise<void>;

  /**
   * Retrieves a definition by its unique identifier.
   * 
   * @param {string} defId - Definition ID to look up
   * @returns {Definition} The definition object
   * @abstract
   */
  protected abstract getDefinitionById(defId: string): Definition;

  /**
   * Retrieves a definition by its service name.
   * 
   * @param {string} name - Service name to look up
   * @returns {Definition} The definition object
   * @abstract
   */
  protected abstract getDefinitionByServiceName(name: string): Definition;


  /**
   * Finds the latest version of a service by its name.
   * This method implements a sophisticated version resolution strategy that:
   * 1. First attempts to find an exact match without version specification
   * 2. If that fails, searches for all versions of the service and returns the latest one
   * 
   * @param {string} serviceName - The name of the service to find. Can be either:
   *                              - A simple name (e.g., 'auth')
   *                              - A name with version (e.g., 'auth@1.0.0')
   * @returns {Definition} The Definition object representing the latest version of the service
   * @throws {Error} If no matching service is found
   * 
   * @example
   * // Returns the latest version of the 'auth' service
   * const latestAuth = findLatestServiceVersion('auth');
   * 
   * @example
   * // Returns the latest version of the 'auth' service
   * const latestAuth = findLatestServiceVersion('auth@1.0.0');
   */
  protected findLatestServiceVersion(serviceName: string): Definition {
    // First, try to find an exact match without version specification
    // This handles cases where the service name is provided without a version
    if (!serviceName.includes('@')) {
      try {
        return this.getDefinitionByServiceName(serviceName);
      } catch (_: any) {
        // If no exact match is found, proceed to version resolution
      }
    }

    // Create a regex pattern to match service names with versions
    // The pattern captures the version number in a group
    const regex = new RegExp(`^${serviceName}@([^@]+)$`);

    // Process all available service names to find matching versions
    const candidates = Array.from(this.getServiceNames())
      // Map each service name to a version-info object if it matches the pattern
      .map((key) => {
        const match = key.match(regex);
        if (match) return { version: match[1], key };
        return null;
      })
      // Filter out non-matching services and ensure type safety
      .filter((x): x is { version: string, key: string } => x !== null)
      // Sort versions in descending order using semver comparison
      .sort((a, b) => semver.rcompare(a.version, b.version));

    // If no matching versions were found, throw an error
    if (candidates.length === 0) {
      throw new Error(`Unknown service: ${serviceName}`);
    }

    // Return the definition for the highest version found
    return this.getDefinitionByServiceName(candidates[0]!.key);
  }
}

```

### File: src/constants.ts
```
/**
 * The maximum value that can be used for unique identifiers (UIDs) in the Netron system.
 * This value is derived from Number.MAX_SAFE_INTEGER with an unsigned right shift operation
 * to ensure it's a valid 32-bit unsigned integer. This is crucial for maintaining
 * compatibility with network protocols and binary operations.
 * 
 * @constant {number} MAX_UID_VALUE
 * @see Number.MAX_SAFE_INTEGER
 */
export const MAX_UID_VALUE = Number.MAX_SAFE_INTEGER >>> 0;

/**
 * A unique Symbol used for context isolation in the Netron framework.
 * This symbol is used to mark and identify context-specific properties and methods,
 * ensuring proper isolation between different execution contexts.
 * 
 * @constant {symbol} CONTEXTIFY_SYMBOL
 */
export const CONTEXTIFY_SYMBOL = Symbol();

/**
 * Annotation used to mark classes and methods as Netron services.
 * This annotation is used in conjunction with decorators to identify
 * and register services within the Netron framework.
 * 
 * @constant {string} SERVICE_ANNOTATION
 */
export const SERVICE_ANNOTATION = 'netron:service';

/**
 * Annotation used to mark public methods and properties of Netron services.
 * This annotation indicates that the marked element should be exposed
 * and accessible to remote peers in the network.
 * 
 * @constant {string} PUBLIC_ANNOTATION
 */
export const PUBLIC_ANNOTATION = 'netron:method';

/**
 * Event emitted when a service is exposed to the network.
 * This event is triggered when a service becomes available for remote access,
 * allowing other peers to discover and interact with it.
 * 
 * @constant {string} NETRON_EVENT_SERVICE_EXPOSE
 */
export const NETRON_EVENT_SERVICE_EXPOSE = 'service:expose';

/**
 * Event emitted when a service is unexposed from the network.
 * This event indicates that a previously available service is no longer
 * accessible to remote peers.
 * 
 * @constant {string} NETRON_EVENT_SERVICE_UNEXPOSE
 */
export const NETRON_EVENT_SERVICE_UNEXPOSE = 'service:unexpose';

/**
 * Event emitted when a new peer connects to the network.
 * This event is triggered when a new peer successfully establishes
 * a connection and becomes part of the Netron network.
 * 
 * @constant {string} NETRON_EVENT_PEER_CONNECT
 */
export const NETRON_EVENT_PEER_CONNECT = 'peer:connect';

/**
 * Event emitted when a peer disconnects from the network.
 * This event indicates that a previously connected peer has
 * terminated its connection or become unavailable.
 * 
 * @constant {string} NETRON_EVENT_PEER_DISCONNECT
 */
export const NETRON_EVENT_PEER_DISCONNECT = 'peer:disconnect';

/**
 * The maximum time (in milliseconds) allowed for establishing a connection
 * with a remote peer. If the connection is not established within this timeframe,
 * the connection attempt will be considered failed.
 * 
 * @constant {number} CONNECT_TIMEOUT
 */
export const CONNECT_TIMEOUT = 5000;

/**
 * The maximum time (in milliseconds) allowed for a request to complete.
 * If a response is not received within this timeframe, the request
 * will be considered timed out and an error will be raised.
 * 
 * @constant {number} REQUEST_TIMEOUT
 */
export const REQUEST_TIMEOUT = 5000;
```

### File: src/core-tasks/abilities.ts
```
import { Abilities } from '../types';
import { Definition } from '../definition';
import { RemotePeer } from '../remote-peer';

/**
 * Handles the exchange of capabilities between peers during connection establishment.
 * This function is responsible for:
 * 1. Processing and storing the remote peer's capabilities
 * 2. Building and returning the local peer's capabilities
 * 
 * @param {RemotePeer} peer - The remote peer instance requesting capabilities exchange
 * @param {Abilities} [remoteAbilities] - Optional capabilities provided by the remote peer
 * @returns {Abilities} The local peer's capabilities including available services and event support
 * 
 * @example
 * // Exchange capabilities with a connecting peer
 * const localAbilities = abilities(remotePeer, {
 *   allowServiceEvents: true,
 *   services: new Map()
 * });
 */
export function abilities(peer: RemotePeer, remoteAbilities?: Abilities) {
  // Process and store remote peer's capabilities if provided
  if (remoteAbilities) {
    // Update the remote peer's abilities with the provided capabilities
    peer.abilities = remoteAbilities;

    // If the remote peer supports service events, set up event subscription
    // Note: Currently commented out as NETRON_EVENT_SERVICE_EXPOSE is not defined
    if (remoteAbilities.allowServiceEvents) {
      // peer.subscribe(NETRON_EVENT_SERVICE_EXPOSE);
    }
  }

  // Initialize the response object with local capabilities
  const result: Abilities = {
    // Map of service definitions available on this Netron instance
    // Key: service name, Value: service definition
    services: new Map<string, Definition>(),

    // Determine if service events are enabled based on Netron configuration
    // Defaults to false if not explicitly configured
    allowServiceEvents: peer.netron.options?.allowServiceEvents ?? false,
  };

  // Populate the services map with all available services
  // Iterate through each service stub in the Netron instance
  for (const [name, stub] of peer.netron.services.entries()) {
    // Add the service definition to the capabilities map
    result.services?.set(name, stub.definition);
  }

  return result;
}

```

### File: src/core-tasks/emit.ts
```
import { RemotePeer } from '../remote-peer';

/**
 * Emits an event to all subscribers registered for a specific event name.
 * This function is responsible for propagating events through the Netron network
 * by executing all registered event handlers for the given event.
 * 
 * @param {RemotePeer} peer - The remote peer instance that will emit the event
 * @param {string} eventName - The name of the event to emit. This should match
 *                            the name used when subscribing to the event
 * @param {...any[]} args - Variable number of arguments that will be passed to
 *                          each event handler. These arguments represent the
 *                          event payload and can be of any type
 * 
 * @example
 * // Emit a service event with some data
 * emit(remotePeer, 'service:update', { id: '123', status: 'active' });
 * 
 * @example
 * // Emit a peer event with multiple arguments
 * emit(remotePeer, 'peer:connected', peerId, timestamp);
 */
export function emit(peer: RemotePeer, eventName: string, ...args: any[]) {
  // Retrieve the set of handlers registered for this event name
  const handlers = peer.eventSubscribers.get(eventName);

  // If handlers exist for this event, execute each one with the provided arguments
  if (handlers) {
    for (const handler of handlers) {
      // Execute the handler with the spread arguments
      // This allows handlers to receive the arguments in their original form
      handler(...args);
    }
  }
}

```

### File: src/core-tasks/expose-service.ts
```
import { ServiceMetadata } from '../types';
import { RemotePeer } from '../remote-peer';

/**
 * Exposes a service to a remote peer in the Netron network.
 * This function acts as a bridge between the core task layer and the peer implementation,
 * delegating the actual service exposure to the peer's exposeRemoteService method.
 * 
 * @param {RemotePeer} peer - The remote peer instance to which the service should be exposed.
 *                           This peer must be connected and authenticated in the Netron network.
 * @param {ServiceMetadata} meta - The metadata describing the service to be exposed.
 *                                This includes information about the service's interface,
 *                                methods, properties, and other relevant configuration.
 * @returns {Promise<void>} A promise that resolves when the service has been successfully
 *                         exposed to the remote peer. The promise may reject if:
 *                         - The peer is not connected
 *                         - The service metadata is invalid
 *                         - The peer does not have permission to expose services
 * 
 * @example
 * // Expose a service to a connected peer
 * const serviceMeta = {
 *   name: 'auth',
 *   version: '1.0.0',
 *   methods: ['login', 'logout'],
 *   properties: ['isAuthenticated']
 * };
 * await expose_service(remotePeer, serviceMeta);
 */
export function expose_service(peer: RemotePeer, meta: ServiceMetadata) {
  return peer.netron.peer.exposeRemoteService(peer, meta);
}

```

### File: src/core-tasks/subscribe.ts
```
import { RemotePeer } from '../remote-peer';

/**
 * Subscribes to events from a remote peer in the Netron network.
 * This function establishes a two-way event subscription mechanism:
 * 1. Creates a handler function that forwards events to the remote peer
 * 2. Stores the subscription in the peer's remote subscriptions map
 * 3. Registers the subscription with the local Netron peer instance
 * 
 * @param {RemotePeer} peer - The remote peer instance to subscribe to events from.
 *                           This peer must be connected and authenticated in the Netron network.
 * @param {string} eventName - The name of the event to subscribe to. This should match
 *                            the event name used when emitting events on the remote peer.
 * @returns {void} This function does not return a value as it operates through side effects.
 * 
 * @example
 * // Subscribe to a service update event from a remote peer
 * subscribe(remotePeer, 'service:update');
 * 
 * @remarks
 * The subscription mechanism works as follows:
 * - When an event is emitted on the remote peer, it will be forwarded to this peer
 * - The handler function created here will execute the 'emit' task on the remote peer
 * - This creates a bidirectional event channel between the peers
 * 
 * @throws {Error} If the peer is not connected or if the event subscription fails
 */
export function subscribe(peer: RemotePeer, eventName: string): void {
  // Create a handler function that will forward events to the remote peer
  // The handler takes any number of arguments and forwards them to the emit task
  const fn = (...args: any[]) => peer.runTask('emit', eventName, ...args);

  // Store the subscription in the peer's remote subscriptions map
  // This allows for tracking and cleanup of subscriptions
  peer.remoteSubscriptions.set(eventName, fn);

  // Register the subscription with the local Netron peer instance
  // This establishes the actual event listening mechanism
  peer.netron.peer.subscribe(eventName, fn);
}

```

### File: src/core-tasks/unexpose-service.ts
```
import { RemotePeer } from '../remote-peer';

/**
 * Removes a previously exposed service from a remote peer in the Netron network.
 * This function acts as a bridge between the core task layer and the peer implementation,
 * delegating the actual service unexposure to the peer's unexposeRemoteService method.
 * 
 * @param {RemotePeer} peer - The remote peer instance from which the service should be unexposed.
 *                           This peer must be connected and authenticated in the Netron network.
 * @param {string} serviceName - The name of the service to unexpose. This should match
 *                              the name used when the service was originally exposed.
 * @returns {Promise<void>} A promise that resolves when the service has been successfully
 *                         unexposed from the remote peer. The promise may reject if:
 *                         - The peer is not connected
 *                         - The service name is invalid
 *                         - The service was not previously exposed
 *                         - The peer does not have permission to unexpose services
 * 
 * @example
 * // Unexpose a service from a connected peer
 * await unexpose_service(remotePeer, 'auth');
 * 
 * @remarks
 * This function is the counterpart to expose_service and is used to clean up service
 * exposure when it is no longer needed. It ensures proper cleanup of resources and
 * event subscriptions associated with the exposed service.
 */
export function unexpose_service(peer: RemotePeer, serviceName: string) {
  return peer.netron.peer.unexposeRemoteService(peer, serviceName);
}

```

### File: src/core-tasks/unref-service.ts
```
import { RemotePeer } from '../remote-peer';

/**
 * Removes a service reference from a remote peer in the Netron network.
 * This function acts as a bridge between the core task layer and the peer implementation,
 * delegating the actual service reference removal to the peer's unrefService method.
 * 
 * @param {RemotePeer} peer - The remote peer instance from which the service reference should be removed.
 *                           This peer must be connected and authenticated in the Netron network.
 * @param {string} defId - The unique identifier of the service definition to unreference.
 *                        This ID should match the one used when the service was originally referenced.
 * @returns {void} This function does not return a value as it operates through side effects.
 * 
 * @example
 * // Remove a service reference from a connected peer
 * unref_service(remotePeer, 'auth-service-123');
 * 
 * @remarks
 * This function is typically used to clean up service references when they are no longer needed.
 * It helps prevent memory leaks and ensures proper resource management in the Netron network.
 * The function assumes that the peer is properly connected and has the necessary permissions
 * to unreference services.
 */
export function unref_service(peer: RemotePeer, defId: string): void {
  peer.netron.peer.unrefService(defId);
}

```

### File: src/core-tasks/unsubscribe.ts
```
import { RemotePeer } from '../remote-peer';

/**
 * Unsubscribes from events previously subscribed to from a remote peer in the Netron network.
 * This function handles the cleanup of event subscriptions by:
 * 1. Retrieving the stored subscription handler from the peer's remote subscriptions map
 * 2. Unsubscribing the handler from the local Netron peer instance
 * 3. Removing the subscription entry from the peer's remote subscriptions map
 * 
 * @param {RemotePeer} peer - The remote peer instance from which to unsubscribe.
 *                           This peer must be connected and have an active subscription
 *                           for the specified event.
 * @param {string} eventName - The name of the event to unsubscribe from. This should match
 *                            the event name used when originally subscribing to the event.
 * @returns {void} This function does not return a value as it operates through side effects.
 * 
 * @example
 * // Unsubscribe from a service update event
 * unsubscribe(remotePeer, 'service:update');
 * 
 * @remarks
 * This function is the counterpart to the subscribe function and is used to clean up
 * event subscriptions when they are no longer needed. It ensures proper cleanup of
 * event handlers and prevents memory leaks in the Netron network.
 * 
 * The function is idempotent - calling it multiple times with the same parameters
 * will not cause errors, as it checks for the existence of the subscription before
 * attempting to remove it.
 */
export function unsubscribe(peer: RemotePeer, eventName: string): void {
  // Retrieve the stored event handler function from the peer's remote subscriptions map
  const fn = peer.remoteSubscriptions.get(eventName);

  // Only proceed with unsubscription if a handler exists for this event
  if (fn) {
    // Remove the event handler from the local Netron peer instance
    // This stops the handler from receiving future events
    peer.netron.peer.unsubscribe(eventName, fn);

    // Clean up the subscription entry from the peer's remote subscriptions map
    // This ensures proper memory management and prevents stale references
    peer.remoteSubscriptions.delete(eventName);
  }
}

```

### File: src/decorators.ts
```
import semver from 'semver';

import { ServiceMetadata } from './types';
import { SERVICE_ANNOTATION } from './constants';

/**
 * Service decorator factory that creates a class decorator for defining Netron services.
 * This decorator processes the service class to extract metadata about its public methods
 * and properties, validates the service name and version, and stores the metadata using
 * reflection.
 * 
 * @param {string} qualifiedName - The fully qualified name of the service in the format 'name[@version]'
 *                                where version is optional and must follow semantic versioning.
 * @returns {ClassDecorator} A decorator function that processes the target class
 * 
 * @throws {Error} If the service name is invalid or doesn't match the required pattern
 * @throws {Error} If the version string is provided but doesn't follow semantic versioning
 * 
 * @example
 * @Service('auth@1.0.0')
 * class AuthService {
 *   @Public()
 *   async login(username: string, password: string): Promise<string> {
 *     // Implementation
 *   }
 * }
 */
export const Service = (qualifiedName: string) => (target: any) => {
  // Parse the qualified name into name and version components
  const [name, version] = qualifiedName.split('@');

  // Regular expression to validate service names
  // Allows alphanumeric characters and dots for namespacing
  const nameRegex = /^[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)*$/;

  // Validate service name format
  if (!name || !nameRegex.test(name)) {
    throw new Error(`Invalid service name "${name}". Only latin letters and dots are allowed.`);
  }

  // Validate version string if provided
  if (version && !semver.valid(version)) {
    throw new Error(`Invalid version "${version}". Version must follow semver.`);
  }

  // Initialize metadata structure
  const metadata: ServiceMetadata = {
    name,
    version: version ?? '',
    properties: {},
    methods: {}
  };

  // Process class methods to extract metadata
  for (const key of Object.getOwnPropertyNames(target.prototype)) {
    const descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);
    if (!descriptor) continue;

    // Skip non-public methods
    const isPublic = Reflect.getMetadata('public', target.prototype, key);
    if (!isPublic) continue;

    // Process method metadata
    if (typeof descriptor.value === 'function') {
      // Extract parameter types and return type using reflection
      const paramTypes = Reflect.getMetadata('design:paramtypes', target.prototype, key) || [];
      const returnType = Reflect.getMetadata('design:returntype', target.prototype, key)?.name || 'void';

      // Store method metadata
      metadata.methods[key] = {
        type: returnType,
        arguments: paramTypes.map((type: any) => type?.name || 'unknown'),
      };
    }
  }

  // Process class properties to extract metadata
  for (const key of Object.keys(new target())) {
    // Skip non-public properties
    const isPublic = Reflect.getMetadata('public', target.prototype, key);
    if (!isPublic) continue;

    // Extract property type and readonly status
    const type = Reflect.getMetadata('design:type', target.prototype, key)?.name || 'unknown';
    const isReadonly = Reflect.getMetadata('readonly', target.prototype, key);

    // Store property metadata
    metadata.properties[key] = {
      type,
      readonly: !!isReadonly,
    };
  }

  // Store the complete metadata on the class using reflection
  Reflect.defineMetadata(SERVICE_ANNOTATION, metadata, target);
};

/**
 * Public decorator factory that creates a property or method decorator.
 * This decorator marks class members as publicly accessible in the Netron service
 * and can optionally mark properties as read-only.
 * 
 * @param {Object} [options] - Configuration options for the decorator
 * @param {boolean} [options.readonly] - If true, marks the property as read-only
 * @returns {PropertyDecorator | MethodDecorator} A decorator function that processes the target member
 * 
 * @example
 * class ExampleService {
 *   @Public({ readonly: true })
 *   public readonly value: string;
 * 
 *   @Public()
 *   public method(): void {
 *     // Implementation
 *   }
 * }
 */
export const Public =
  (options?: { readonly?: boolean }) =>
    (target: any, propertyKey: string | symbol, descriptor?: PropertyDescriptor) => {
      // Mark the member as public
      Reflect.defineMetadata('public', true, target, propertyKey);

      // For properties (when descriptor is undefined), handle readonly flag
      if (!descriptor) {
        Reflect.defineMetadata('readonly', options?.readonly, target, propertyKey);
      }
    };

/**
 * Alias for the Service decorator, providing an alternative naming convention.
 * @see Service
 */
export const NetronService = Service;

/**
 * Alias for the Public decorator, providing an alternative naming convention.
 * @see Public
 */
export const NetronMethod = Public;

```

### File: src/definition.ts
```
import { randomUUID } from 'node:crypto';

import { ServiceMetadata } from './types';

/**
 * The Definition class represents a service definition within the Netron framework.
 * It encapsulates all necessary information about a service, including its unique identifier,
 * associated peer, and comprehensive metadata. This class serves as a fundamental building block
 * for service discovery, registration, and communication within the Netron ecosystem.
 * 
 * @class Definition
 * @property {string} parentId - Optional identifier of a parent service definition, used for
 *                              establishing hierarchical relationships between services.
 *                              Defaults to an empty string when no parent is specified.
 * @property {string} id - The unique identifier of this service definition, generated using
 *                        cryptographically secure random UUID generation.
 * @property {string} peerId - The identifier of the peer that owns or provides this service.
 * @property {ServiceMetadata} meta - Detailed metadata describing the service's capabilities,
 *                                   including its name, version, available methods, and properties.
 */
export class Definition {
  /**
   * The identifier of the parent service definition, if this service is part of a hierarchy.
   * This property enables the creation of service trees and facilitates service composition.
   * 
   * @type {string}
   * @default ''
   */
  public parentId: string = '';

  /**
   * Constructs a new Definition instance with the specified parameters.
   * 
   * @param {string} id - A unique identifier for the service definition. This should be
   *                      generated using the static nextId() method to ensure uniqueness.
   * @param {string} peerId - The identifier of the peer that owns or provides this service.
   *                          This links the service to its provider in the network.
   * @param {ServiceMetadata} meta - The service metadata object containing detailed
   *                                information about the service's capabilities and interface.
   * @throws {Error} If the provided id is not a valid UUID or if the metadata is incomplete.
   */
  constructor(
    public id: string,
    public peerId: string,
    public meta: ServiceMetadata
  ) { }

  /**
   * Generates a new cryptographically secure unique identifier using the Node.js crypto module.
   * This method uses the randomUUID() function to create a version 4 UUID that is suitable
   * for use as a service definition identifier.
   * 
   * @static
   * @returns {string} A new UUID v4 string that can be used as a unique identifier.
   * @example
   * const newId = Definition.nextId();
   * // Returns something like: '123e4567-e89b-12d3-a456-426614174000'
   */
  static nextId(): string {
    return randomUUID();
  }
}

```

### File: src/index.ts
```
import 'reflect-metadata';

export * from './uid';
export * from './types';
export * from './utils';
export * from './packet';
export * from './netron';
export * from './interface';
export * from './constants';
export * from './local-peer';
export * from './definition';
export * from './decorators';
export * from './predicates';
export * from './remote-peer';
export * from './service-stub';
export * from './task-manager';
export * from './readable-stream';
export * from './writable-stream';
export * from './service-discovery';
```

### File: src/interface.ts
```
import { Reference } from './reference';
import { Definition } from './definition';
import { AbstractPeer } from './abstract-peer';
import { StreamReference } from './stream-reference';
import { isNetronStream, isNetronService, isServiceInterface } from './predicates';

/**
 * List of internal properties that can be read from the Interface instance.
 * These properties are used for internal bookkeeping and should not be exposed
 * as part of the public API.
 * 
 * @constant {string[]} INTERNAL_READ_PROPERTIES
 */
const INTERNAL_READ_PROPERTIES = ['$def', '$peer', 'waitForAssigned', '$pendingPromises', 'then'];

/**
 * List of internal properties that can be written to the Interface instance.
 * These properties are used for internal state management and should not be
 * modified by external code.
 * 
 * @constant {string[]} INTERNAL_WRITE_PROPERTIES
 */
const INTERNAL_WRITE_PROPERTIES = ['$def', '$peer'];

/**
 * The Interface class implements a sophisticated proxy mechanism for remote service interaction
 * within the Netron framework. It serves as a transparent bridge between local code and remote
 * services, handling method calls, property access, and type conversion between different
 * execution contexts.
 * 
 * This class uses JavaScript's Proxy API to intercept and handle all property access and
 * method calls, providing a seamless experience for developers while maintaining proper
 * type safety and error handling.
 * 
 * @class Interface
 * @property {Definition} $def - The service definition containing metadata about available
 *                              methods and properties
 * @property {AbstractPeer} $peer - The peer instance responsible for network communication
 */
export class Interface {
  /**
   * A Map tracking pending promises for asynchronous property assignments.
   * This is used to ensure proper handling of concurrent property updates
   * and to provide a mechanism for waiting on property assignment completion.
   * 
   * @private
   * @type {Map<string, Promise<void>>}
   */
  private $pendingPromises = new Map<string, Promise<void>>();

  /**
   * Constructs a new Interface instance with the specified service definition and peer.
   * The constructor returns a Proxy that intercepts all property access and method calls,
   * providing transparent remote service interaction.
   * 
   * @param {Definition} [def] - The service definition containing metadata about available
   *                            methods and properties
   * @param {AbstractPeer} [peer] - The peer instance responsible for network communication
   * @returns {Proxy} A Proxy instance that intercepts property access and method calls
   */
  constructor(
    public $def?: Definition,
    public $peer?: AbstractPeer
  ) {
    return new Proxy(this, {
      /**
       * Intercepts property access on the Interface instance.
       * This handler implements the core logic for remote service interaction:
       * - Method calls are converted to asynchronous remote procedure calls
       * - Property access triggers remote property retrieval
       * - Internal properties are handled directly
       * 
       * @param {Interface} target - The target Interface instance
       * @param {string} prop - The name of the property being accessed
       * @returns {any} The property value or a function for method calls
       * @throws {Error} If the interface is invalid or the member is unknown
       */
      get: (target: Interface, prop: string) => {
        if (!this.$def) {
          throw new Error('Invalid interface: Service definition is missing');
        }

        if (this.$def?.meta.methods[prop]) {
          return async function (...args: any[]) {
            const processedArgs = target.$processArgs(args);
            return $peer?.call($def!.id, prop, processedArgs);
          };
        }

        if ($def?.meta.properties[prop]) {
          return $peer?.get($def.id, prop);
        }

        if (!INTERNAL_READ_PROPERTIES.includes(prop)) {
          throw new Error(`Unknown member: '${prop}' is not defined in the service interface`);
        }

        return Reflect.get(target, prop);
      },

      /**
       * Intercepts property assignment on the Interface instance.
       * This handler manages asynchronous property updates and ensures proper
       * type conversion and validation before remote updates are performed.
       * 
       * @param {Interface} target - The target Interface instance
       * @param {string} prop - The name of the property being set
       * @param {any} value - The value being assigned
       * @returns {boolean} true if the assignment was successful
       * @throws {Error} If the interface is invalid, the member is unknown, or the property is read-only
       */
      set: (target: Interface, prop: string, value: any) => {
        if (INTERNAL_WRITE_PROPERTIES.includes(prop)) {
          Reflect.set(target, prop, value);
          return true;
        }

        if (!this.$def) {
          throw new Error('Invalid interface: Service definition is missing');
        }

        if (!$def?.meta.properties[prop]) {
          throw new Error(`Unknown member: '${prop}' is not defined in the service interface`);
        }

        if (this.$def?.meta.properties[prop]?.readonly) {
          throw new Error(`Property is not writable: '${prop}' is marked as readonly`);
        }

        let resolvePromise: () => void = () => { };
        let rejectPromise: (reason?: any) => void = () => { };

        const promise = new Promise<void>((resolve, reject) => {
          resolvePromise = resolve;
          rejectPromise = reject;
        });

        this.$pendingPromises.set(prop, promise);

        (async () => {
          try {
            value = await this.$processValue(value);
            await $peer?.set($def!.id, prop, value);
            resolvePromise();
            this.$pendingPromises.delete(prop);
          } catch (error) {
            rejectPromise(error);
          }
        })();

        return true;
      },
    });
  }

  /**
   * Waits for the completion of a property assignment operation.
   * This method is particularly useful when you need to ensure that a property
   * update has been successfully propagated to the remote service before proceeding.
   * 
   * @param {string} prop - The name of the property to wait for
   * @returns {Promise<void>} A promise that resolves when the assignment is complete
   * @throws {Error} If the assignment operation fails
   */
  public async waitForAssigned(prop: string): Promise<void> {
    try {
      const promise = this.$pendingPromises.get(prop);
      return promise ? await promise : Promise.resolve();
    } catch (error) {
      this.$pendingPromises.delete(prop);
      return Promise.reject(error);
    }
  }

  /**
   * Processes a value to convert it into a format suitable for network transmission.
   * This method handles various special types that require special serialization:
   * - Service interfaces are converted to references
   * - Streams are converted to stream references
   * - Other types are passed through unchanged
   * 
   * @private
   * @param {any} value - The value to process
   * @returns {any} The processed value
   * @throws {Error} If the value type is not supported
   */
  private $processValue(value: any): any {
    if (isServiceInterface(value)) {
      if (!value.$def) {
        throw new Error('Service interface is not valid: Missing service definition');
      }
      return new Reference(value.$def.id);
    } else if (isNetronService(value)) {
      throw Error('Unsupported value type: Direct service exposure is not yet implemented');
    } else if (isNetronStream(value)) {
      return StreamReference.from(value);
    }
    return value;
  }

  /**
   * Processes an array of arguments by converting each argument using $processValue.
   * This method ensures that all arguments passed to remote methods are properly
   * serialized for network transmission.
   * 
   * @private
   * @param {any[]} args - The array of arguments to process
   * @returns {any[]} The array of processed arguments
   */
  private $processArgs(args: any[]): any[] {
    return args.map((arg) => this.$processValue(arg));
  }

  /**
   * Factory method for creating new Interface instances.
   * This method provides a more convenient way to create Interface instances
   * while maintaining proper type safety.
   * 
   * @static
   * @param {Definition} def - The service definition
   * @param {AbstractPeer} peer - The peer instance
   * @returns {Interface} A new Interface instance
   */
  static create(def: Definition, peer: AbstractPeer): Interface {
    return new Interface(def, peer);
  }
}

```

### File: src/local-peer.ts
```
import { Netron } from './netron';
import { Interface } from './interface';
import { Definition } from './definition';
import { RemotePeer } from './remote-peer';
import { ServiceStub } from './service-stub';
import { AbstractPeer } from './abstract-peer';
import { isServiceInterface, isServiceDefinition } from './predicates';
import { EventSubscriber, ServiceMetadata, ServiceExposeEvent } from './types';
import {
  getQualifiedName,
  getServiceMetadata,
  getServiceEventName,
} from './utils';
import {
  NETRON_EVENT_SERVICE_EXPOSE,
  NETRON_EVENT_SERVICE_UNEXPOSE,
} from './constants';

/**
 * LocalPeer is a concrete implementation of AbstractPeer that manages local service instances
 * and their corresponding stubs within the Netron network. It handles service exposure,
 * unexposure, and provides methods for service interaction and event management.
 * 
 * @extends AbstractPeer
 */
export class LocalPeer extends AbstractPeer {
  /**
   * A mapping of service definition IDs to their corresponding ServiceStub instances.
   * This map maintains the relationship between service definitions and their stubs.
   */
  public stubs = new Map<string, ServiceStub>();

  /**
   * A mapping of service instances to their corresponding ServiceStub instances.
   * This map tracks all active service instances and their associated stubs.
   */
  public serviceInstances = new Map<InstanceType<any>, ServiceStub>();

  /**
   * Constructs a new LocalPeer instance.
   * 
   * @param {Netron} netron - The Netron network instance this peer belongs to.
   * @throws {Error} If the provided Netron instance is invalid.
   */
  constructor(netron: Netron) {
    super(netron, netron.id);
    this.abilities = {
      allowServiceEvents: netron.options?.allowServiceEvents ?? false,
    };
  }

  /**
   * Exposes a local service instance to the network, making it available for remote access.
   * This method performs several validations and creates necessary service artifacts.
   * 
   * @param {any} instance - The service instance to expose.
   * @returns {Promise<Definition>} The definition of the newly exposed service.
   * @throws {Error} If the service is invalid, already exposed, or if the service name is already in use.
   * @throws {Error} If the service metadata cannot be retrieved.
   */
  async exposeService(instance: any): Promise<Definition> {
    const meta = getServiceMetadata(instance);
    if (!meta) {
      throw new Error('Invalid service: Service metadata could not be retrieved');
    }

    const existingStub = this.serviceInstances.get(instance);
    if (existingStub) {
      throw new Error(`Service instance already exposed: ${meta.name}`);
    }

    const serviceKey = getQualifiedName(meta.name, meta.version);
    if (this.netron.services.has(serviceKey)) {
      throw new Error(`Service already exposed: ${serviceKey}`);
    }

    const stub = new ServiceStub(this, instance, meta);
    const def = stub.definition;

    this.stubs.set(def.id, stub);
    this.netron.services.set(serviceKey, stub);
    this.serviceInstances.set(instance, stub);

    this.netron.emitSpecial(NETRON_EVENT_SERVICE_EXPOSE, getServiceEventName(serviceKey), {
      name: def.meta.name,
      version: def.meta.version,
      qualifiedName: serviceKey,
      peerId: this.id,
      definition: def,
    } as ServiceExposeEvent);

    await this.netron.discovery?.updateServices(this.netron.getExposedServices());

    return def;
  }

  /**
   * Exposes a remote service from another peer, creating necessary local artifacts
   * to interact with the remote service.
   * 
   * @param {RemotePeer} peer - The remote peer providing the service.
   * @param {ServiceMetadata} meta - The metadata describing the remote service.
   * @returns {Definition} The definition of the exposed remote service.
   * @throws {Error} If the remote peer is invalid or the service metadata is incomplete.
   */
  exposeRemoteService(peer: RemotePeer, meta: ServiceMetadata) {
    const def = new Definition(Definition.nextId(), peer.id, meta);
    const iInstance = Interface.create(def, peer);
    const stub = new ServiceStub(this, iInstance, def);

    this.stubs.set(def.id, stub);
    this.netron.services.set(meta.name, stub);
    this.serviceInstances.set(iInstance, stub);
    peer.definitions.set(def.id, def);

    this.netron.emitSpecial(NETRON_EVENT_SERVICE_EXPOSE, getServiceEventName(def.meta.name), {
      name: def.meta.name,
      version: def.meta.version,
      qualifiedName: getQualifiedName(def.meta.name, def.meta.version),
      peerId: this.id,
      remotePeerId: peer.id,
      definition: def,
    } as ServiceExposeEvent);
    return def;
  }

  /**
   * Unexposes a local service, removing it from the network and cleaning up associated resources.
   * 
   * @param {string} serviceName - The name of the service to unexpose.
   * @returns {Promise<void>}
   * @throws {Error} If the service is not found or if there are issues during cleanup.
   */
  async unexposeService(serviceName: string) {
    const def = this.getDefinitionByServiceName(serviceName);
    const defId = def.id;
    for (const i of this.interfaces.values()) {
      if (i.instance.$def?.parentId === defId) {
        this.releaseInterface(i.instance);
      }
    }
    this.netron.services.delete(serviceName);
    const stub = this.stubs.get(defId);
    if (stub) {
      this.serviceInstances.delete(stub.instance);
      this.stubs.delete(defId);
    }

    this.netron.emitSpecial(NETRON_EVENT_SERVICE_UNEXPOSE, getServiceEventName(serviceName), {
      name: def.meta.name,
      version: def.meta.version,
      qualifiedName: serviceName,
      peerId: this.id,
      defId,
    });

    await this.netron.discovery?.updateServices(this.netron.getExposedServices());
  }

  /**
   * Unexposes a remote service, cleaning up local resources and notifying the remote peer.
   * 
   * @param {RemotePeer} peer - The remote peer providing the service.
   * @param {string} serviceName - The name of the service to unexpose.
   * @returns {string} The ID of the unexposed service definition.
   * @throws {Error} If the service is not found or if there are issues during cleanup.
   */
  unexposeRemoteService(peer: RemotePeer, serviceName: string) {
    const def = this.getDefinitionByServiceName(serviceName);
    const defId = def.id;
    for (const i of this.interfaces.values()) {
      if (i.instance.$def?.parentId === defId) {
        this.releaseInterface(i.instance);
      }
    }
    peer.definitions.delete(defId);
    this.netron.services.delete(serviceName);
    const stub = this.stubs.get(defId);
    if (stub) {
      this.serviceInstances.delete(stub.instance);
      this.stubs.delete(defId);
    }

    this.netron.emitSpecial(NETRON_EVENT_SERVICE_UNEXPOSE, getServiceEventName(serviceName), {
      name: def.meta.name,
      version: def.meta.version,
      qualifiedName: serviceName,
      peerId: this.id,
      remotePeerId: peer.id,
      defId,
    });

    return def.id;
  }

  /**
   * Internal method to release an interface and clean up associated resources.
   * 
   * @param {Interface} iInstance - The interface instance to release.
   * @returns {Promise<void>}
   * @protected
   */
  protected async releaseInterfaceInternal(iInstance: Interface): Promise<void> {
    this.unrefService(iInstance.$def?.id);
  }

  /**
   * Creates a reference to a service instance, establishing necessary relationships
   * between the instance and its definition.
   * 
   * @param {any} instance - The service instance to reference.
   * @param {Definition} parentDef - The parent definition this service belongs to.
   * @returns {Definition} The definition of the referenced service.
   * @throws {Error} If the service instance is invalid or if metadata cannot be retrieved.
   */
  refService(instance: any, parentDef: Definition) {
    const existingStub = this.serviceInstances.get(instance);
    if (existingStub) {
      return existingStub.definition;
    }

    const meta = isServiceInterface(instance) ? instance.$def!.meta : getServiceMetadata(instance);
    const stub = new ServiceStub(this, instance, meta);
    stub.definition.parentId = parentDef.id;
    this.serviceInstances.set(instance, stub);
    this.stubs.set(stub.definition.id, stub);
    return stub.definition;
  }

  /**
   * Removes a reference to a service, cleaning up associated resources if no other
   * references exist.
   * 
   * @param {string} [defId] - The definition ID of the service to unreference.
   */
  unrefService(defId?: string) {
    if (defId) {
      const stub = this.stubs.get(defId);
      if (stub) {
        this.serviceInstances.delete(stub.instance);

        if (!this.netron.services.has(getQualifiedName(stub.definition.meta.name, stub.definition.meta.version))) {
          this.stubs.delete(stub.definition.id);
        }
      }
    }
  }

  /**
   * Subscribes to an event.
   * @param {string} eventName - The name of the event.
   * @param {EventSubscriber} handler - The event handler.
   */
  subscribe(eventName: string, handler: EventSubscriber) {
    this.netron.on(eventName, handler);
  }

  /**
   * Removes an event listener from the Netron network event system.
   * This method allows a peer to stop receiving notifications for specific events
   * by removing the previously registered event handler.
   * 
   * @param {string} eventName - The name of the event to unsubscribe from.
   *                            This should match the event name used in the corresponding subscribe() call.
   * @param {EventSubscriber} handler - The event handler function to remove.
   *                                   This must be the same function reference that was used in subscribe().
   * @returns {void}
   */
  unsubscribe(eventName: string, handler: EventSubscriber) {
    this.netron.removeListener(eventName, handler);
  }

  /**
   * Sets a property value on a service stub identified by its definition ID.
   * This method provides a way to update service properties remotely through the network.
   * 
   * @param {string} defId - The unique identifier of the service definition.
   * @param {string} name - The name of the property to set.
   * @param {any} value - The new value to assign to the property.
   * @returns {Promise<void>} A promise that resolves when the property has been set.
   * @throws {Error} If the service definition is unknown or if the property cannot be set.
   */
  async set(defId: string, name: string, value: any) {
    return this.getStubByDefinitionId(defId).set(name, value);
  }

  /**
   * Retrieves a property value from a service stub identified by its definition ID.
   * This method handles the asynchronous nature of remote property access and
   * processes the result appropriately.
   * 
   * @param {string} defId - The unique identifier of the service definition.
   * @param {string} name - The name of the property to retrieve.
   * @returns {Promise<any>} A promise that resolves with the property value.
   * @throws {Error} If the service definition is unknown or if the property cannot be accessed.
   */
  async get(defId: string, name: string) {
    return this.processResult(await this.getStubByDefinitionId(defId).get(name));
  }

  /**
   * Invokes a method on a service stub identified by its definition ID.
   * This method handles remote method calls, including parameter passing and
   * result processing.
   * 
   * @param {string} defId - The unique identifier of the service definition.
   * @param {string} method - The name of the method to invoke.
   * @param {any[]} args - An array of arguments to pass to the method.
   * @returns {Promise<any>} A promise that resolves with the method's return value.
   * @throws {Error} If the service definition is unknown or if the method call fails.
   */
  async call(defId: string, method: string, args: any[]) {
    return this.processResult(await this.getStubByDefinitionId(defId).call(method, args));
  }

  /**
   * Checks whether a service stub exists for a given definition ID.
   * This method provides a way to verify the existence of a service before
   * attempting operations on it.
   * 
   * @param {string} defId - The unique identifier of the service definition to check.
   * @returns {boolean} True if a stub exists for the given definition ID, false otherwise.
   */
  hasStub(defId: string) {
    return this.stubs.has(defId);
  }

  /**
   * Retrieves the names of all services available in the Netron network.
   * This method provides a way to discover available services in the network.
   * 
   * @returns {string[]} An array of service names available in the network.
   */
  getServiceNames() {
    return this.netron.getServiceNames();
  }

  /**
   * Retrieves a service stub by its definition ID.
   * This method is a core utility for accessing service stubs and includes
   * error handling for unknown definitions.
   * 
   * @param {string} defId - The unique identifier of the service definition.
   * @returns {ServiceStub} The service stub associated with the given definition ID.
   * @throws {Error} If no stub exists for the given definition ID.
   */
  getStubByDefinitionId(defId: string) {
    const stub = this.stubs.get(defId);
    if (stub === void 0) {
      throw new Error(`Unknown definition: ${defId}.`);
    }
    return stub;
  }

  /**
   * Retrieves a service definition by its unique identifier.
   * This protected method is used internally to access service definitions
   * and includes error handling for unknown definitions.
   * 
   * @param {string} defId - The unique identifier of the service definition.
   * @returns {Definition} The service definition associated with the given ID.
   * @throws {Error} If no definition exists for the given ID.
   */
  protected getDefinitionById(defId: string): Definition {
    const stub = this.stubs.get(defId);
    if (stub === void 0) {
      throw new Error(`Unknown definition: ${defId}.`);
    }
    return stub.definition;
  }

  /**
   * Retrieves a service definition by its service name.
   * This protected method provides a way to look up service definitions
   * using their human-readable names.
   * 
   * @param {string} name - The name of the service to look up.
   * @returns {Definition} The service definition associated with the given name.
   * @throws {Error} If no service exists with the given name.
   */
  protected getDefinitionByServiceName(name: string): Definition {
    const stub = this.netron.services.get(name);
    if (stub === void 0) {
      throw new Error(`Unknown service: ${name}.`);
    }
    return stub.definition;
  }

  /**
   * Processes the result of a service call or property access.
   * This private method handles special cases in service results, such as
   * converting service definitions into appropriate interface objects.
   * 
   * @param {any} result - The raw result to process.
   * @returns {any} The processed result, which may be transformed based on its type.
   */
  private processResult(result: any) {
    if (isServiceDefinition(result)) {
      return this.queryInterfaceByDefId(result.id, result);
    }
    return result;
  }
}

```

### File: src/netron.ts
```
import path from 'node:path';
import { Redis } from 'ioredis';
import { randomUUID } from 'node:crypto';
import { IncomingMessage } from 'node:http';
import { WebSocket, WebSocketServer } from 'ws';
import { AsyncEventEmitter } from '@devgrid/async-emitter';

import { NetronOptions } from './types';
import { LocalPeer } from './local-peer';
import { RemotePeer } from './remote-peer';
import { getPeerEventName } from './utils';
import { ServiceStub } from './service-stub';
import { Task, TaskManager } from './task-manager';
import { ServiceInfo, ServiceDiscovery } from './service-discovery';
import { CONNECT_TIMEOUT, NETRON_EVENT_PEER_CONNECT, NETRON_EVENT_PEER_DISCONNECT } from './constants';

/**
 * The main Netron class that manages WebSocket connections, services, and peer communication.
 * This class serves as the central hub for creating and managing distributed system components.
 * It extends AsyncEventEmitter to provide asynchronous event handling capabilities.
 * 
 * @class Netron
 * @extends AsyncEventEmitter
 * @description Core class for managing distributed system components and peer-to-peer communication
 * @example
 * // Create a new Netron instance
 * const netron = await Netron.create({
 *   listenHost: 'localhost',
 *   listenPort: 8080,
 *   discoveryEnabled: true,
 *   discoveryRedisUrl: 'redis://localhost:6379'
 * });
 */
export class Netron extends AsyncEventEmitter {
  /**
   * Unique identifier for this Netron instance.
   * Generated automatically using randomUUID() if not provided in options.
   * Used for peer identification and connection management.
   * 
   * @type {string}
   * @public
   * @example
   * console.log(netron.id); // '550e8400-e29b-41d4-a716-446655440000'
   */
  public id: string;

  /**
   * WebSocket server instance for handling incoming connections.
   * Only initialized when running in server mode (when listenHost and listenPort are provided).
   * 
   * @type {WebSocketServer | undefined}
   * @private
   * @description Manages WebSocket connections and handles the WebSocket protocol
   */
  private wss?: WebSocketServer;

  /**
   * Map of special events that need to be processed sequentially.
   * Used to ensure ordered processing of related events and prevent race conditions.
   * Key: event ID, Value: array of {name, data} pairs
   * 
   * @type {Map<string, { name: string; data: any }[]>}
   * @private
   * @description Maintains event queue for ordered processing and prevents race conditions
   */
  private ownEvents: Map<string, { name: string; data: any }[]> = new Map();

  /**
   * The local peer instance representing this Netron instance.
   * Used for exposing local services and handling local operations.
   * 
   * @type {LocalPeer}
   * @public
   * @description Represents the local node in the distributed network
   */
  public peer: LocalPeer;

  /**
   * Map of connected remote peers.
   * Key: peer ID, Value: RemotePeer instance
   * Used to track and manage all active peer connections.
   * 
   * @type {Map<string, RemotePeer>}
   * @public
   * @description Registry of all active peer connections in the network
   */
  public peers: Map<string, RemotePeer> = new Map();

  /**
   * Task manager instance for handling remote task execution.
   * Manages task registration, execution, and timeout handling.
   * 
   * @type {TaskManager}
   * @public
   * @description Orchestrates distributed task execution across the network
   */
  public taskManager: TaskManager;

  /**
   * Flag indicating whether the Netron instance has been started.
   * Used to prevent multiple start attempts and ensure proper initialization.
   * 
   * @type {boolean}
   * @private
   * @description Prevents multiple initialization attempts and tracks instance state
   */
  private isStarted: boolean = false;

  /**
   * Map of exposed services.
   * Key: qualified service name (name:version), Value: ServiceStub instance
   * Used to track and manage all available services.
   * 
   * @type {Map<string, ServiceStub>}
   * @public
   * @description Registry of all available services in the network
   */
  public services = new Map<string, ServiceStub>();

  /**
   * Configuration options for this Netron instance.
   * Contains settings for timeouts, reconnection, and other behaviors.
   * 
   * @type {NetronOptions}
   * @public
   * @description Configuration parameters for the Netron instance
   */
  public options: NetronOptions;

  /**
   * Service discovery instance for managing service registration and discovery.
   * Only initialized when discovery is enabled in options.
   * 
   * @type {ServiceDiscovery | undefined}
   * @public
   * @description Manages service discovery and registration in the distributed network
   */
  public discovery?: ServiceDiscovery;

  /**
   * Redis client instance for service discovery.
   * Only initialized when discovery is enabled in options.
   * 
   * @type {Redis | undefined}
   * @private
   * @description Redis client for service discovery coordination
   */
  private discoveryRedis?: Redis;

  /**
   * Creates a new Netron instance with the specified options.
   * Initializes the task manager and local peer.
   * 
   * @constructor
   * @param {NetronOptions} [options] - Configuration options for the Netron instance
   * @throws {Error} If required options are missing or invalid
   * @example
   * const netron = new Netron({
   *   id: 'custom-id',
   *   taskTimeout: 5000,
   *   taskOverwriteStrategy: 'replace'
   * });
   */
  constructor(options?: NetronOptions) {
    super();

    this.options = options ?? {};
    this.id = options?.id ?? randomUUID();

    this.taskManager = new TaskManager({
      timeout: options?.taskTimeout,
      overwriteStrategy: options?.taskOverwriteStrategy,
    });

    this.peer = new LocalPeer(this);
  }

  /**
   * Starts the Netron instance, initializing the WebSocket server and loading tasks.
   * Loads core tasks from the specified directory and sets up the WebSocket server if configured.
   * 
   * @method start
   * @async
   * @throws {Error} If Netron is already started
   * @returns {Promise<void>} Resolves when initialization is complete
   * @example
   * await netron.start();
   * console.log('Netron instance started successfully');
   */
  async start() {
    if (this.isStarted) {
      throw new Error('Netron already started');
    }

    await this.taskManager.loadTasksFromDir(path.join(__dirname, 'core-tasks'));

    if (!this.options?.listenHost || !this.options?.listenPort) {
      this.isStarted = true;
      return Promise.resolve();
    }

    return new Promise<void>((resolve, reject) => {
      this.wss = new WebSocketServer({
        host: this.options?.listenHost,
        port: this.options?.listenPort,
      });

      this.wss.on('listening', async () => {
        this.isStarted = true;

        if (this.options.discoveryEnabled && this.options.discoveryRedisUrl) {
          this.discoveryRedis = new Redis(this.options.discoveryRedisUrl);
          this.discovery = new ServiceDiscovery(
            this.discoveryRedis,
            this.id,
            `${this.options.listenHost}:${this.options.listenPort}`,
            this.getExposedServices(),
            {
              heartbeatInterval: this.options.discoveryHeartbeatInterval,
              heartbeatTTL: this.options.discoveryHeartbeatTTL,
              pubSubEnabled: this.options.discoveryPubSubEnabled ?? true,
            }
          );
          this.discovery.startHeartbeat();
          await this.discovery.subscribeToEvents((event) => {
            this.emit('discovery:event', event);
          });
        }

        resolve();
      });

      this.wss.on('error', (err) => {
        reject(err);
      });

      this.wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
        const peerId = new URL(req.url!, 'ws://localhost').searchParams.get('id');
        if (!peerId) {
          ws.close();
          return;
        }
        const peer = new RemotePeer(ws, this, peerId);
        this.peers.set(peer.id, peer);

        ws.send(JSON.stringify({ type: 'id', id: this.id }));

        this.emitSpecial(NETRON_EVENT_PEER_CONNECT, getPeerEventName(peer.id), { peerId });

        ws.on('close', () => {
          this.peers.delete(peerId);
          this.emitSpecial(NETRON_EVENT_PEER_DISCONNECT, getPeerEventName(peerId), { peerId });
        });

        peer.init(false, this.options);
      });
    });
  }

  /**
   * Stops the Netron instance, closing the WebSocket server and cleaning up resources.
   * Properly shuts down all connections and services.
   * 
   * @method stop
   * @async
   * @returns {Promise<void>} Resolves when shutdown is complete
   * @example
   * await netron.stop();
   */
  async stop() {
    if (this.wss) {
      this.wss.close();
      this.wss = undefined;
    }

    if (this.discovery) {
      await this.discovery.shutdown();
      await this.discoveryRedis!.quit();
      this.discovery = undefined;
      this.discoveryRedis = undefined;
    }

    this.isStarted = false;
  }

  /**
   * Establishes a WebSocket connection to a remote peer with robust error handling and automatic reconnection.
   * This method implements a sophisticated connection protocol that includes:
   * - Initial connection establishment with timeout protection
   * - Handshake protocol validation
   * - Automatic reconnection with exponential backoff
   * - Connection state tracking and cleanup
   * - Event emission for connection lifecycle events
   * 
   * The reconnection mechanism uses an exponential backoff strategy starting at 1 second,
   * doubling each attempt up to a maximum of 30 seconds. The maximum number of attempts
   * can be configured through the Netron options.
   * 
   * @method connect
   * @async
   * @param {string} address - The WebSocket URL of the remote peer to connect to
   * @param {boolean} [reconnect=true] - Enables automatic reconnection on connection loss
   * @returns {Promise<RemotePeer>} A promise that resolves to the established RemotePeer instance
   * @throws {Error} When connection fails, times out, or handshake validation fails
   * @example
   * const peer = await netron.connect('ws://example.com:8080');
   */
  async connect(address: string, reconnect = true): Promise<RemotePeer> {
    const baseDelay = 1000; // Initial reconnection delay in milliseconds
    let reconnectAttempts = 0;
    let manuallyDisconnected = false;

    const connectPeer = (): Promise<RemotePeer> => new Promise<RemotePeer>((resolve, reject) => {
      // Set up connection timeout
      const timeoutId = setTimeout(() => {
        reject(new Error('Connection timeout'));
      }, this.options?.connectTimeout ?? CONNECT_TIMEOUT);

      // Initialize WebSocket connection with peer ID
      const ws = new WebSocket(`${address}?id=${this.id}`);
      const peer = new RemotePeer(ws, this, address);

      let resolved = false;

      // Handle successful connection establishment
      ws.once('open', () => {
        clearTimeout(timeoutId);
        // Wait for initial handshake message
        ws.once('message', async (message: ArrayBuffer, isBinary: boolean) => {
          if (!isBinary) {
            try {
              const data = JSON.parse(message.toString()) as { type: 'id'; id: string };
              if (data.type === 'id') {
                // Complete peer initialization
                peer.id = data.id;
                this.peers.set(peer.id, peer);
                await peer.init(true, this.options);

                // Set up disconnect handling
                peer.once('manual-disconnect', () => {
                  manuallyDisconnected = true;
                });

                // Handle connection closure
                ws.once('close', () => {
                  this.peers.delete(peer.id);
                  this.emitSpecial(NETRON_EVENT_PEER_DISCONNECT, getPeerEventName(peer.id), { peerId: peer.id });

                  if (reconnect && !manuallyDisconnected) {
                    attemptReconnect();
                  }
                });

                resolved = true;
                reconnectAttempts = 0;
                this.emitSpecial(NETRON_EVENT_PEER_CONNECT, getPeerEventName(peer.id), { peerId: peer.id });
                resolve(peer);
              } else {
                ws.close();
                reject(new Error('Invalid handshake'));
              }
            } catch (error) {
              ws.close();
              reject(error);
            }
          } else {
            ws.close();
            reject(new Error('Invalid handshake'));
          }
        });
      });

      // Handle connection errors
      ws.on('error', (err) => {
        clearTimeout(timeoutId);
        if (!resolved) {
          reject(err);
        }
      });

      // Handle premature connection closure
      ws.on('close', () => {
        clearTimeout(timeoutId);
        if (!resolved) {
          reject(new Error('Connection closed prematurely'));
        }
      });
    });

    /**
     * Implements the reconnection logic with exponential backoff.
     * This function will attempt to reconnect to the peer with increasing delays
     * between attempts, up to the configured maximum number of attempts.
     */
    const attemptReconnect = () => {
      if (this.options.maxReconnectAttempts && reconnectAttempts >= this.options.maxReconnectAttempts) {
        console.error(`Reconnect attempts exceeded (${this.options.maxReconnectAttempts}). Giving up.`);
        return;
      }

      const delay = Math.min(baseDelay * 2 ** reconnectAttempts, 30000);
      console.info(`Reconnecting to ${address} in ${delay} ms (attempt ${reconnectAttempts + 1}/${this.options.maxReconnectAttempts ?? 'unlimited'})...`);

      setTimeout(async () => {
        reconnectAttempts++;
        try {
          await connectPeer();
          console.info(`Successfully reconnected to ${address}.`);
        } catch (err) {
          console.warn(`Reconnect failed (${reconnectAttempts}/${this.options.maxReconnectAttempts ?? 'unlimited'}):`);
          attemptReconnect();
        }
      }, delay);
    };

    return connectPeer();
  }

  /**
   * Gracefully disconnects a remote peer from the Netron network.
   * This method performs a clean disconnection by:
   * 1. Finding the peer in the active peers map
   * 2. Initiating the disconnect sequence
   * 3. Removing the peer from the active peers registry
   * 4. Emitting a disconnect event to notify other components
   * 
   * @param {string} peerId - The unique identifier of the peer to disconnect
   * @returns {void}
   * @throws {Error} If the peer cannot be found or if the disconnect process fails
   * @example
   * netron.disconnect('peer-123');
   */
  disconnect(peerId: string) {
    const peer = this.peers.get(peerId);
    if (peer) {
      peer.disconnect();
      this.peers.delete(peerId);
      this.emitSpecial(NETRON_EVENT_PEER_DISCONNECT, getPeerEventName(peerId), { peerId });
    }
  }

  /**
   * Retrieves a list of all service names currently registered in the Netron network.
   * This method provides a snapshot of all available services at the time of invocation.
   * The returned array is a shallow copy to prevent external modifications to the internal service registry.
   * 
   * @returns {string[]} An array containing the qualified names of all registered services
   * @example
   * const services = netron.getServiceNames();
   * console.log('Available services:', services);
   */
  getServiceNames() {
    return [...this.services.keys()];
  }

  /**
   * Registers a new task with the Netron task manager.
   * This method allows for the addition of custom tasks that can be executed
   * across the network. The task function should be designed to be serializable
   * and should handle its own error cases appropriately.
   * 
   * @param {Task} fn - The task function to be registered
   * @returns {string} The unique identifier assigned to the newly registered task
   * @throws {Error} If the task registration fails or if the task function is invalid
   * @example
   * const taskId = netron.addTask(async (data) => {
   *   // Task implementation
   *   return processedData;
   * });
   */
  addTask(fn: Task) {
    return this.taskManager.addTask(fn);
  }

  /**
   * Executes a task on a specified remote peer.
   * This method handles the orchestration of remote task execution, including:
   * - Task serialization and transmission
   * - Result collection and deserialization
   * - Error handling and propagation
   * 
   * @param {RemotePeer} peer - The remote peer instance where the task should be executed
   * @param {string} name - The name of the task to execute
   * @param {...any} args - Variable number of arguments to be passed to the task
   * @returns {Promise<any>} A promise that resolves with the task execution result
   * @throws {Error} If the task execution fails or if the peer is unavailable
   * @example
   * const result = await netron.runTask(peer, 'processData', data);
   */
  async runTask(peer: RemotePeer, name: string, ...args: any[]) {
    return await this.taskManager.runTask(name, peer, ...args);
  }

  /**
   * Removes special events associated with a specific ID from the event queue.
   * This method is used to clean up event queues when they are no longer needed
   * or when the associated operation has been completed or cancelled.
   * 
   * @param {string} id - The unique identifier of the events to be removed
   * @returns {void}
   * @example
   * netron.deleteSpecialEvents('operation-123');
   */
  deleteSpecialEvents(id: string) {
    this.ownEvents.delete(id);
  }

  /**
   * Emits a special event with guaranteed sequential processing.
   * This method implements a sophisticated event emission system that:
   * 1. Queues events for sequential processing
   * 2. Implements a timeout mechanism for event processing
   * 3. Handles error cases gracefully
   * 4. Ensures proper cleanup of event queues
   * 
   * The method maintains event order and prevents race conditions by processing
   * events in a first-in-first-out manner with a maximum processing time of 5 seconds.
   * 
   * @param {string} event - The name of the event to emit
   * @param {string} id - The unique identifier for this event sequence
   * @param {any} data - The data payload to be emitted with the event
   * @returns {Promise<void>} A promise that resolves when event processing is complete
   * @throws {Error} If event processing times out or fails
   */
  async emitSpecial(event: string, id: string, data: any) {
    const events = this.ownEvents.get(id) || [];
    events.push({ name: event, data });
    this.ownEvents.set(id, events);

    if (events.length > 1) {
      return;
    }

    while (events.length > 0) {
      const eventData = events.shift();
      if (eventData === void 0) {
        break;
      }
      try {
        const timeoutPromise = new Promise((_, reject) => {
          const timeoutId = setTimeout(() => {
            reject(new Error(`Emit timeout for event: ${eventData.name}`));
          }, 5000);
          this.emitParallel(eventData.name, eventData.data)
            .finally(() => clearTimeout(timeoutId))
            .catch(reject);
        });

        await timeoutPromise;
      } catch (err: any) {
        console.error(`Event emit error: ${err.message}`);
      }
    }

    this.ownEvents.delete(id);
  }

  /**
   * Creates and initializes a new Netron instance.
   * This factory method provides a convenient way to create and start a Netron
   * instance in a single operation. It handles the complete initialization
   * sequence, including:
   * - Instance creation with provided options
   * - Network initialization
   * - Service registration
   * - Event system setup
   * 
   * @param {NetronOptions} [options] - Optional configuration parameters for the Netron instance
   * @returns {Promise<Netron>} A promise that resolves with the initialized Netron instance
   * @throws {Error} If initialization fails or if required resources are unavailable
   */
  static async create(options?: NetronOptions) {
    const netron = new Netron(options);
    await netron.start();
    return netron;
  }
  /**
   * Retrieves a list of all services currently exposed by this Netron instance.
   * This method provides a standardized way to access service metadata for discovery
   * and registration purposes. The returned information includes both service names
   * and versions, which are essential for service matching and version compatibility.
   * 
   * @method getExposedServices
   * @public
   * @returns {ServiceInfo[]} An array of ServiceInfo objects containing:
   *                         - name: The unique identifier of the service
   *                         - version: The semantic version of the service
   * 
   * @example
   * // Get all exposed services
   * const services = netron.getExposedServices();
   * // Result: [{ name: 'auth', version: '1.0.0' }, { name: 'storage', version: '2.1.0' }]
   * 
   * @remarks
   * This method is primarily used by the service discovery system to:
   * 1. Register services with the discovery mechanism
   * 2. Provide service information to connecting peers
   * 3. Enable service version compatibility checking
   * 
   * The returned array is derived from the internal services Map, ensuring that
   * the information is always up-to-date with the current service registry.
   */
  public getExposedServices(): ServiceInfo[] {
    return Array.from(this.services.values()).map(stub => ({
      name: stub.definition.meta.name,
      version: stub.definition.meta.version,
    }));
  }
}

```

### File: src/packet/index.ts
```
import { Buffer } from 'buffer';
import { SmartBuffer } from '@devgrid/smartbuffer';

import { Packet } from './packet';
import { serializer } from './serializer';
import { PacketType, TYPE_STREAM, PacketImpulse } from './types';

export * from './types';

/**
 * Creates a new packet with the specified parameters.
 * This function serves as a factory method for creating Packet instances with predefined properties.
 * 
 * @param {number} id - A unique numeric identifier for the packet. Used for tracking and correlation.
 * @param {PacketImpulse} impulse - The impulse type that determines the packet's behavior and processing rules.
 * @param {PacketType} action - The type of packet, defining its role in the communication protocol.
 * @param {any} data - The payload data to be encapsulated within the packet. Can be of any type.
 * @returns {Packet} A newly instantiated Packet object with the specified properties set.
 * 
 * @example
 * const packet = createPacket(123, PacketImpulse.REQUEST, PacketType.DATA, { message: 'Hello' });
 */
export const createPacket = (id: number, impulse: PacketImpulse, action: PacketType, data: any) => {
  const packet = new Packet(id);
  packet.setImpulse(impulse);
  packet.setType(action);
  packet.data = data;
  return packet;
};

/**
 * Creates a new stream packet with stream-specific parameters.
 * This specialized factory method creates packets designed for streaming data,
 * with additional metadata for stream management and control.
 * 
 * @param {number} id - A unique numeric identifier for the packet.
 * @param {number} streamId - The unique identifier of the stream this packet belongs to.
 * @param {number} streamIndex - The sequential position of this packet within the stream.
 * @param {boolean} isLast - Flag indicating if this is the final packet in the stream.
 * @param {boolean} isLive - Flag indicating if this is a live streaming packet.
 * @param {any} data - The actual payload data to be transmitted in the stream.
 * @returns {Packet} A Packet instance configured for streaming with the specified properties.
 * 
 * @example
 * const streamPacket = createStreamPacket(123, 456, 0, false, true, { video: 'chunk1' });
 */
export const createStreamPacket = (
  id: number,
  streamId: number,
  streamIndex: number,
  isLast: boolean,
  isLive: boolean,
  data: any
) => {
  const packet = new Packet(id);
  packet.setImpulse(1);
  packet.setType(TYPE_STREAM);
  packet.setStreamInfo(streamId, streamIndex, isLast, isLive);
  packet.data = data;
  return packet;
};

/**
 * Encodes a Packet instance into a binary buffer for network transmission.
 * This function handles the serialization of packet data into a format suitable
 * for network transmission, including proper byte ordering and stream metadata.
 * 
 * @param {Packet} packet - The Packet instance to be encoded.
 * @returns {Buffer} A Buffer containing the binary representation of the packet.
 * 
 * @remarks
 * The encoding process follows this structure:
 * 1. Packet ID (4 bytes, big-endian)
 * 2. Flags (1 byte)
 * 3. Serialized data payload
 * 4. Stream metadata (if applicable)
 * 
 * @throws {Error} If the packet data cannot be properly serialized.
 */
export const encodePacket = (packet: Packet) => {
  const buf = new SmartBuffer(SmartBuffer.DEFAULT_CAPACITY, true);

  // Write the packet's unique identifier and flags to the buffer.
  buf.writeUInt32BE(packet.id);
  buf.writeUInt8(packet.flags);

  // Encode the packet's data using the serializer and write it to the buffer.
  serializer.encode(packet.data, buf);

  // If the packet is part of a stream, write the stream-specific information.
  if (packet.isStreamChunk()) {
    buf.writeUInt32BE(packet.streamId!);
    buf.writeUInt32BE(packet.streamIndex!);
  }

  // Convert the SmartBuffer to a standard Buffer and return it.
  return buf.toBuffer();
};

/**
 * Decodes a binary buffer into a Packet instance.
 * This function handles the deserialization of network data back into a Packet object,
 * including proper parsing of headers and stream metadata.
 * 
 * @param {Buffer | ArrayBuffer} buf - The binary data to decode into a packet.
 * @returns {Packet} A reconstructed Packet instance from the binary data.
 * @throws {Error} If the packet data is invalid or cannot be decoded.
 * 
 * @remarks
 * The decoding process follows this structure:
 * 1. Read packet ID (4 bytes, big-endian)
 * 2. Read flags (1 byte)
 * 3. Deserialize data payload
 * 4. Read stream metadata (if applicable)
 * 
 * @example
 * const packet = decodePacket(receivedBuffer);
 */
export const decodePacket = (buf: Buffer | ArrayBuffer) => {
  const buffer = SmartBuffer.wrap(buf);
  const pkt = new Packet(buffer.readUInt32BE());
  pkt.flags = buffer.readUInt8()!;

  // Attempt to decode the packet's data using the serializer.
  const result = serializer.decoder.tryDecode(buffer);
  if (!result) {
    throw new Error('Invalid packet');
  }
  pkt.data = result.value;

  // If the packet is part of a stream, read the stream-specific information.
  if (pkt.isStreamChunk()) {
    pkt.streamId = buffer.readUInt32BE();
    pkt.streamIndex = buffer.readUInt32BE();
  }
  return pkt;
};

export { Packet, serializer };

```

### File: src/packet/packet.ts
```
import { Uid } from '../uid';
import { PacketType, TYPE_STREAM, PacketImpulse } from './types';

/**
 * Extracts the value of a single bit from a number at a specified position.
 * This is a low-level bit manipulation utility function used throughout the packet implementation.
 * 
 * @param {number} target - The source number from which to extract the bit value
 * @param {number} offset - The zero-based position of the bit to extract (0 = least significant bit)
 * @returns {number} The value of the bit at the specified position (0 or 1)
 * 
 * @example
 * // Get the 3rd bit (position 2) of the number 5 (binary 101)
 * const bit = getBit(5, 2); // Returns 1
 */
const getBit = (target: number, offset: number): number => (target >> offset) & 1;

/**
 * Clears a range of bits in a number, setting them to 0.
 * This operation preserves all other bits in the number while zeroing out the specified range.
 * 
 * @param {number} target - The number in which to clear bits
 * @param {number} offset - The starting position of the bits to clear
 * @param {number} count - The number of consecutive bits to clear
 * @returns {number} A new number with the specified bits cleared
 * 
 * @example
 * // Clear bits 2-4 (inclusive) of the number 255 (binary 11111111)
 * const result = clearBits(255, 2, 3); // Returns 227 (binary 11100011)
 */
const clearBits = (target: number, offset: number, count: number): number => {
  let result = target;
  for (let i = offset; i < offset + count; ++i) {
    result &= ~(1 << i);
  }
  return result;
};

/**
 * Writes a value into a range of bits in a number.
 * This operation combines clearing the target bits and then setting them to the new value.
 * 
 * @param {number} target - The number in which to write bits
 * @param {number} val - The value to write into the bits
 * @param {number} offset - The starting position to write the bits
 * @param {number} count - The number of bits to write
 * @returns {number} A new number with the specified bits updated
 * 
 * @example
 * // Write the value 3 (binary 11) into bits 2-3 of the number 0
 * const result = writeBits(0, 3, 2, 2); // Returns 12 (binary 1100)
 */
const writeBits = (target: number, val: number, offset: number, count: number): number => {
  let result = target;
  for (let i = 0; i < count; ++i) {
    if (val & (1 << i)) {
      result |= 1 << (offset + i);
    }
  }
  return result;
};

/**
 * Reads a range of bits from a number and returns them as a new value.
 * This operation extracts consecutive bits and combines them into a single number.
 * 
 * @param {number} target - The number from which to read bits
 * @param {number} offset - The starting position to read bits
 * @param {number} count - The number of bits to read
 * @returns {number} The value of the read bits combined into a single number
 * 
 * @example
 * // Read bits 2-3 from the number 12 (binary 1100)
 * const value = readBits(12, 2, 2); // Returns 3 (binary 11)
 */
const readBits = (target: number, offset: number, count: number): number => {
  let val = 0;
  for (let i = 0; i < count; ++i) {
    if (getBit(target, offset + i)) {
      val |= 1 << i;
    }
  }
  return val;
};

const IMPULSE_OFFSET = 6; // Bit position for the impulse flag
const ERROR_OFFSET = 7;   // Bit position for the error flag
const TYPE_OFFSET = 0;    // Starting bit position for the type field
const TYPE_SIZE = 4;      // Number of bits used for the type field
const EOS_OFFSET = 4;     // Bit position for the end of stream flag
const LIVE_OFFSET = 5;    // Bit position for the live stream flag

const uid = new Uid();

/**
 * Represents a Netron network packet with its control flags and payload data.
 * 
 * The packet structure consists of:
 * - flags: Control flags (uint8) containing various packet metadata
 * - id: Packet identifier (uint32) for tracking and correlation
 * - data: The actual payload data of the packet
 * - streamId: Optional unique identifier for stream packets (uint32)
 * - streamIndex: Optional chunk number for stream packets (uint32)
 * 
 * The control flags are organized as follows:
 * 
 * | Field    | Offset | Bits | Range  | Description                                      |
 * |----------|--------|------|--------|--------------------------------------------------|
 * | type     | 0      | 4    | 0-15   | Packet type (see ACTION_*)                       |
 * | eos      | 4      | 1    | 0-1    | End of stream flag                               |
 * | live     | 5      | 1    | 0-1    | Live stream indicator                            |
 * | impulse  | 6      | 1    | 0-1    | Request/response flag                            |
 * | error    | 7      | 1    | 0-1    | Error indicator                                  |
 * 
 * @class Packet
 * @property {number} flags - The control flags of the packet (uint8)
 * @property {any} data - The payload data of the packet
 * @property {number} [streamId] - Unique identifier for stream packets (uint32)
 * @property {number} [streamIndex] - Chunk number for stream packets (uint32)
 */
export class Packet {
  /** Control flags of the packet (uint8) containing various metadata bits */
  public flags = 0;

  /** The actual payload data of the packet */
  public data: any;

  /** Unique identifier for stream packets (uint32) */
  public streamId?: number;

  /** Chunk number for stream packets (uint32) */
  public streamIndex?: number;

  /**
   * Creates a new Packet instance with the specified identifier.
   * The identifier is used for tracking and correlation of packets in the network.
   * 
   * @param {number} id - The unique identifier for this packet (uint32)
   * @throws {Error} If the provided ID is not a valid unsigned 32-bit integer
   */
  constructor(public id: number) { }

  /**
   * Sets the packet type in the control flags while preserving all other flags.
   * The type field occupies 4 bits (0-3) in the flags byte and determines
   * the primary purpose of the packet in the protocol.
   * 
   * @param {PacketType} type - The type to set in the packet flags
   * @throws {Error} If the type value exceeds the 4-bit range (0-15)
   */
  setType(type: PacketType) {
    this.flags = writeBits(clearBits(this.flags, TYPE_OFFSET, TYPE_SIZE), type, TYPE_OFFSET, TYPE_SIZE);
  }

  /**
   * Retrieves the packet type from the control flags.
   * This method extracts the 4-bit type field from the flags byte.
   * 
   * @returns {PacketType} The type of the packet as specified in the flags
   */
  getType(): PacketType {
    return readBits(this.flags, TYPE_OFFSET, TYPE_SIZE) as PacketType;
  }

  /**
   * Sets the impulse flag in the control flags.
   * The impulse flag (bit 6) indicates whether this is a request (1) or response (0) packet.
   * This flag is crucial for request-response pattern implementation in the protocol.
   * 
   * @param {PacketImpulse} val - The value to set for the impulse flag (0 or 1)
   * @throws {Error} If the value is not 0 or 1
   */
  setImpulse(val: PacketImpulse) {
    this.flags = (this.flags & ~(1 << IMPULSE_OFFSET)) | (val << IMPULSE_OFFSET);
  }

  /**
   * Retrieves the impulse flag from the control flags.
   * 
   * @returns {PacketImpulse} The value of the impulse flag (0 or 1)
   */
  getImpulse(): PacketImpulse {
    return getBit(this.flags, IMPULSE_OFFSET) as PacketImpulse;
  }

  /**
   * Sets the error flag in the control flags.
   * The error flag (bit 7) indicates whether this packet represents an error condition.
   * When set, the packet's data typically contains error information.
   * 
   * @param {0 | 1} val - The value to set for the error flag (0 or 1)
   * @throws {Error} If the value is not 0 or 1
   */
  setError(val: 0 | 1) {
    this.flags = (this.flags & ~(1 << ERROR_OFFSET)) | (val << ERROR_OFFSET);
  }

  /**
   * Retrieves the error flag from the control flags.
   * 
   * @returns {number} The value of the error flag (0 or 1)
   */
  getError() {
    return getBit(this.flags, ERROR_OFFSET);
  }

  /**
   * Sets comprehensive stream information in the packet.
   * This method updates both the stream metadata fields and the corresponding control flags
   * for stream-specific attributes (end-of-stream and live stream indicators).
   * 
   * @param {number} streamId - The unique identifier for the stream (uint32)
   * @param {number} streamIndex - The sequential position of this chunk in the stream (uint32)
   * @param {boolean} isLast - Indicates if this is the final chunk in the stream
   * @param {boolean} isLive - Indicates if this is a live streaming packet
   * @throws {Error} If streamId or streamIndex are not valid unsigned 32-bit integers
   */
  setStreamInfo(streamId: number, streamIndex: number, isLast: boolean, isLive: boolean) {
    this.streamId = streamId;
    this.streamIndex = streamIndex;
    this.flags = writeBits(writeBits(this.flags, isLast ? 1 : 0, EOS_OFFSET, 1), isLive ? 1 : 0, LIVE_OFFSET, 1);
  }

  /**
   * Determines if this packet is part of a stream.
   * This check is based on the packet type being set to TYPE_STREAM.
   * 
   * @returns {boolean} True if the packet is a stream chunk, false otherwise
   */
  isStreamChunk(): boolean {
    return this.getType() === TYPE_STREAM;
  }

  /**
   * Checks if this packet represents the final chunk of a stream.
   * This is determined by the end-of-stream flag (bit 4) in the control flags.
   * 
   * @returns {boolean} True if the packet is the last chunk of a stream, false otherwise
   */
  isLastChunk(): boolean {
    return getBit(this.flags, EOS_OFFSET) === 1;
  }

  /**
   * Determines if this packet is part of a live stream.
   * This is indicated by the live stream flag (bit 5) in the control flags.
   * 
   * @returns {boolean} True if the stream is live, false otherwise
   */
  isLive(): boolean {
    return getBit(this.flags, LIVE_OFFSET) === 1;
  }

  /**
   * Generates a new unique packet identifier using the UID generator.
   * This method is used to ensure unique packet identification across the network.
   * 
   * @returns {number} A new unique packet identifier (uint32)
   */
  static nextId(): number {
    return uid.next();
  }

  /**
   * Resets the packet ID generator to its initial state.
   * This method should be used with caution as it may cause ID collisions
   * if packets with old IDs are still in transit.
   */
  static resetId() {
    uid.reset();
  }
}

```

### File: src/packet/serializer.ts
```
import { SmartBuffer } from '@devgrid/smartbuffer';
import { Serializer, registerCommonTypesFor } from '@devgrid/messagepack';

import { Reference } from '../reference';
import { Definition } from '../definition';
import { StreamReference } from '../stream-reference';

/**
 * Global serializer instance for the Netron application.
 * This serializer is responsible for converting complex objects into binary format
 * and vice versa, enabling efficient network transmission and storage.
 * 
 * @type {Serializer}
 * @constant
 */
export const serializer = new Serializer();

/**
 * Registers common data types with the serializer.
 * This enables the serializer to handle standard JavaScript types like
 * numbers, strings, arrays, and objects without additional configuration.
 */
registerCommonTypesFor(serializer);

/**
 * Registers custom serialization handlers for Netron-specific types.
 * Each type is assigned a unique identifier and provided with custom
 * encoding and decoding functions to handle its specific serialization needs.
 */
serializer
  /**
   * Registers serialization handlers for the Definition class.
   * Definition objects represent service definitions in the Netron network
   * and contain metadata about available services.
   * 
   * @param {number} 109 - Unique type identifier for Definition objects
   * @param {Definition} - The class constructor for Definition objects
   * @param {Function} - Encoder function that writes Definition properties to buffer
   * @param {Function} - Decoder function that reconstructs Definition from buffer
   */
  .register(
    109,
    Definition,
    /**
     * Encodes a Definition object into a binary buffer.
     * The encoding process preserves the object's identity and relationships
     * by serializing its id, parentId, peerId, and metadata.
     * 
     * @param {Definition} obj - The Definition object to encode
     * @param {SmartBuffer} buf - The buffer to write the encoded data to
     */
    (obj: Definition, buf: SmartBuffer) => {
      serializer.encode(obj.id, buf);
      serializer.encode(obj.parentId, buf);
      serializer.encode(obj.peerId, buf);
      serializer.encode(obj.meta, buf);
    },
    /**
     * Decodes a Definition object from a binary buffer.
     * Reconstructs the object's state by reading its properties in the same
     * order they were written during encoding.
     * 
     * @param {SmartBuffer} buf - The buffer containing the encoded Definition
     * @returns {Definition} A new Definition instance with restored properties
     */
    (buf: SmartBuffer) => {
      const id = serializer.decode(buf);
      const parentId = serializer.decode(buf);
      const peerId = serializer.decode(buf);
      const meta = serializer.decode(buf);
      const def = new Definition(id, peerId, meta);
      def.parentId = parentId;
      return def;
    }
  )
  /**
   * Registers serialization handlers for the Reference class.
   * Reference objects represent service references in the Netron network,
   * linking to specific service definitions.
   * 
   * @param {number} 108 - Unique type identifier for Reference objects
   * @param {Reference} - The class constructor for Reference objects
   * @param {Function} - Encoder function that writes Reference properties to buffer
   * @param {Function} - Decoder function that reconstructs Reference from buffer
   */
  .register(
    108,
    Reference,
    /**
     * Encodes a Reference object into a binary buffer.
     * Only the defId property is serialized as it uniquely identifies
     * the referenced service definition.
     * 
     * @param {Reference} obj - The Reference object to encode
     * @param {SmartBuffer} buf - The buffer to write the encoded data to
     */
    (obj: any, buf: SmartBuffer) => {
      serializer.encode(obj.defId, buf);
    },
    /**
     * Decodes a Reference object from a binary buffer.
     * Creates a new Reference instance using the decoded defId.
     * 
     * @param {SmartBuffer} buf - The buffer containing the encoded Reference
     * @returns {Reference} A new Reference instance with the restored defId
     */
    (buf: SmartBuffer) => new Reference(serializer.decode(buf))
  )
  /**
   * Registers serialization handlers for the StreamReference class.
   * StreamReference objects represent stream connections in the Netron network,
   * containing information about stream type, direction, and associated peer.
   * 
   * @param {number} 107 - Unique type identifier for StreamReference objects
   * @param {StreamReference} - The class constructor for StreamReference objects
   * @param {Function} - Encoder function that writes StreamReference properties to buffer
   * @param {Function} - Decoder function that reconstructs StreamReference from buffer
   */
  .register(
    107,
    StreamReference,
    /**
     * Encodes a StreamReference object into a binary buffer.
     * Serializes the stream's identity, type, liveness status, and associated peer.
     * 
     * @param {StreamReference} obj - The StreamReference object to encode
     * @param {SmartBuffer} buf - The buffer to write the encoded data to
     */
    (obj: any, buf: SmartBuffer) => {
      serializer.encode(obj.streamId.toString(), buf);
      buf.writeUInt8(obj.type === 'writable' ? 1 : 0);
      buf.writeUInt8(obj.isLive ? 1 : 0);
      serializer.encode(obj.peerId, buf);
    },
    /**
     * Decodes a StreamReference object from a binary buffer.
     * Reconstructs the stream reference with its type, liveness status,
     * and associated peer information.
     * 
     * @param {SmartBuffer} buf - The buffer containing the encoded StreamReference
     * @returns {StreamReference} A new StreamReference instance with restored properties
     */
    (buf: SmartBuffer) => {
      const streamId = Number(serializer.decode(buf));
      const streamType = buf.readUInt8() === 1 ? 'writable' : 'readable';
      const isLive = buf.readUInt8() === 1;
      const peerId = serializer.decode(buf);
      return new StreamReference(streamId, streamType, isLive, peerId);
    }
  );

```

### File: src/packet/types.ts
```
/**
 * Represents the impulse flag of a network packet, which determines whether the packet
 * is a request or a response in the request-response communication pattern.
 * 
 * @typedef {number} PacketImpulse
 * @property {0} RESPONSE - Indicates that the packet is a response to a previous request
 * @property {1} REQUEST - Indicates that the packet is initiating a new request
 * 
 * @example
 * // Create a request packet
 * const requestPacket = new Packet();
 * requestPacket.setImpulse(1); // Set as request
 * 
 * // Create a response packet
 * const responsePacket = new Packet();
 * responsePacket.setImpulse(0); // Set as response
 */
export type PacketImpulse = 0 | 1;

/**
 * Defines the set of packet types used in the Netron network protocol.
 * Each type represents a specific operation or action that can be performed
 * through network communication.
 * 
 * @constant {number} TYPE_PING - Used for connection health checks and latency measurement
 * @constant {number} TYPE_GET - Requests retrieval of a property value from a remote peer
 * @constant {number} TYPE_SET - Requests modification of a property value on a remote peer
 * @constant {number} TYPE_CALL - Initiates execution of a remote method or function
 * @constant {number} TYPE_TASK - Triggers execution of a predefined remote task
 * @constant {number} TYPE_STREAM - Indicates streaming data transmission
 * @constant {number} TYPE_STREAM_ERROR - Signals an error condition during stream transmission
 * 
 * @example
 * // Create a packet for property retrieval
 * const packet = new Packet();
 * packet.setType(TYPE_GET);
 */
export const TYPE_PING = 0x00;
export const TYPE_GET = 0x01;
export const TYPE_SET = 0x02;
export const TYPE_CALL = 0x03;
export const TYPE_TASK = 0x04;
export const TYPE_STREAM = 0x05;
export const TYPE_STREAM_ERROR = 0x06;

/**
 * Represents the union type of all possible packet types in the Netron protocol.
 * This type is used to ensure type safety when working with packet types throughout
 * the codebase.
 * 
 * @typedef {number} PacketType
 * @property {number} TYPE_GET - Property retrieval request
 * @property {number} TYPE_SET - Property modification request
 * @property {number} TYPE_CALL - Remote method invocation
 * @property {number} TYPE_TASK - Remote task execution
 * @property {number} TYPE_STREAM - Data streaming
 * @property {number} TYPE_STREAM_ERROR - Stream error notification
 * 
 * @example
 * function handlePacket(packet: Packet) {
 *   const type: PacketType = packet.getType();
 *   switch(type) {
 *     case TYPE_GET:
 *       // Handle property retrieval
 *       break;
 *     case TYPE_SET:
 *       // Handle property modification
 *       break;
 *   }
 * }
 */
export type PacketType = typeof TYPE_GET | typeof TYPE_SET | typeof TYPE_CALL | typeof TYPE_TASK | typeof TYPE_STREAM | typeof TYPE_STREAM_ERROR;

/**
 * Enumerates the possible types of packets within a data stream.
 * This enum is used to manage the flow and state of streaming data transmission.
 * 
 * @enum {number}
 * @property {number} FIRST - Indicates the initial packet of a new stream
 * @property {number} MIDDLE - Represents intermediate packets in an ongoing stream
 * @property {number} LAST - Marks the final packet of a stream
 * 
 * @example
 * // Handle stream packets based on their position
 * function processStreamPacket(packet: Packet) {
 *   switch(packet.streamType) {
 *     case StreamType.FIRST:
 *       // Initialize stream processing
 *       break;
 *     case StreamType.MIDDLE:
 *       // Process stream data
 *       break;
 *     case StreamType.LAST:
 *       // Finalize stream processing
 *       break;
 *   }
 * }
 */
export enum StreamType {
  FIRST = 0x01,
  MIDDLE = 0x02,
  LAST = 0x03,
}

```

### File: src/predicates.ts
```

import { Netron } from './netron';
import { Interface } from './interface';
import { Reference } from './reference';
import { LocalPeer } from './local-peer';
import { Definition } from './definition';
import { ServiceStub } from './service-stub';
import { AbstractPeer } from './abstract-peer';
import { SERVICE_ANNOTATION } from './constants';
import { StreamReference } from './stream-reference';
import { NetronWritableStream } from './writable-stream';
import { NetronReadableStream } from './readable-stream';

/**
 * Determines whether the provided object is an instance of the Netron class.
 * This predicate function is essential for type checking and runtime validation
 * of Netron instances throughout the application.
 * 
 * @param {any} obj - The object to be evaluated for Netron instance membership
 * @returns {boolean} Returns true if the object is a Netron instance, false otherwise
 * @example
 * const netron = new Netron();
 * isNetron(netron); // returns true
 * isNetron({}); // returns false
 */
export const isNetron = (obj: any) => obj instanceof Netron;

/**
 * Validates if the given object is an instance of the Definition class.
 * This predicate is crucial for service definition validation and type checking
 * in the Netron service architecture.
 * 
 * @param {any} obj - The object to be checked for Definition instance membership
 * @returns {boolean} Returns true if the object is a Definition instance, false otherwise
 * @see Definition
 */
export const isServiceDefinition = (obj: any) => obj instanceof Definition;

/**
 * Verifies if the provided object is an instance of the Reference class.
 * This predicate function is used to identify service references in the Netron
 * distributed system architecture.
 * 
 * @param {any} obj - The object to be evaluated for Reference instance membership
 * @returns {boolean} Returns true if the object is a Reference instance, false otherwise
 * @see Reference
 */
export const isServiceReference = (obj: any) => obj instanceof Reference;

/**
 * Determines whether the given object is an instance of the Interface class.
 * This predicate is essential for interface validation in the Netron service
 * communication layer.
 * 
 * @param {any} obj - The object to be checked for Interface instance membership
 * @returns {boolean} Returns true if the object is an Interface instance, false otherwise
 * @see Interface
 */
export const isServiceInterface = (obj: any) => obj instanceof Interface;

/**
 * Validates if the provided object is an instance of the ServiceStub class.
 * This predicate function is used to identify service stubs in the Netron
 * service proxy system.
 * 
 * @param {any} obj - The object to be evaluated for ServiceStub instance membership
 * @returns {boolean} Returns true if the object is a ServiceStub instance, false otherwise
 * @see ServiceStub
 */
export const isServiceStub = (obj: any) => obj instanceof ServiceStub;

/**
 * Checks if the given object is an instance of the AbstractPeer class.
 * This predicate is fundamental for peer type validation in the Netron
 * peer-to-peer communication system.
 * 
 * @param {any} obj - The object to be checked for AbstractPeer instance membership
 * @returns {boolean} Returns true if the object is an AbstractPeer instance, false otherwise
 * @see AbstractPeer
 */
export const isNetronPeer = (obj: any) => obj instanceof AbstractPeer;

/**
 * Determines whether the provided object is an instance of the LocalPeer class.
 * This predicate function is used to identify local peer instances in the Netron
 * distributed system.
 * 
 * @param {any} obj - The object to be evaluated for LocalPeer instance membership
 * @returns {boolean} Returns true if the object is a LocalPeer instance, false otherwise
 * @see LocalPeer
 */
export const isNetronOwnPeer = (obj: any) => obj instanceof LocalPeer;

/**
 * Validates if the given object is a Netron service by checking for the presence
 * of the SERVICE_ANNOTATION metadata on its constructor. This predicate is crucial
 * for service identification and validation in the Netron service architecture.
 * 
 * @param {any} obj - The object to be checked for Netron service membership
 * @returns {boolean} Returns true if the object is a Netron service, false otherwise
 * @see SERVICE_ANNOTATION
 */
export const isNetronService = (obj: any) => {
  if (obj && typeof obj === 'object' && obj.constructor) {
    return Reflect.hasMetadata(SERVICE_ANNOTATION, obj.constructor);
  }
  return false;
};

/**
 * Determines whether the provided object is an instance of either NetronReadableStream
 * or NetronWritableStream. This predicate is essential for stream type validation
 * in the Netron streaming system.
 * 
 * @param {any} obj - The object to be evaluated for stream instance membership
 * @returns {boolean} Returns true if the object is a Netron stream instance, false otherwise
 * @see NetronReadableStream
 * @see NetronWritableStream
 */
export const isNetronStream = (obj: any) => obj instanceof NetronReadableStream || obj instanceof NetronWritableStream;

/**
 * Validates if the given object is an instance of the StreamReference class.
 * This predicate function is used to identify stream references in the Netron
 * streaming system.
 * 
 * @param {any} obj - The object to be checked for StreamReference instance membership
 * @returns {boolean} Returns true if the object is a StreamReference instance, false otherwise
 * @see StreamReference
 */
export const isNetronStreamReference = (obj: any) => obj instanceof StreamReference;
```

### File: src/readable-stream.ts
```
import { Readable, ReadableOptions } from 'stream';

import { Packet } from './packet';
import { RemotePeer } from './remote-peer';

/**
 * Maximum number of packets that can be buffered in the stream before
 * triggering a buffer overflow error. This limit helps prevent memory
 * exhaustion in high-throughput scenarios.
 */
const MAX_BUFFER_SIZE = 10_000;

/**
 * Configuration options for creating a new NetronReadableStream instance.
 * Extends the standard Node.js Readable stream options with Netron-specific
 * parameters required for peer-to-peer communication.
 * 
 * @interface NetronReadableStreamOptions
 * @extends ReadableOptions
 * @property {RemotePeer} peer - The remote peer this stream is associated with
 * @property {number} streamId - Unique identifier for this stream
 * @property {boolean} [isLive=false] - Whether this is a live streaming connection
 */
export interface NetronReadableStreamOptions extends ReadableOptions {
  peer: RemotePeer;
  streamId: number;
  isLive?: boolean;
}

/**
 * A specialized Readable stream implementation for the Netron distributed system.
 * This class handles the reception and ordered delivery of data packets from
 * remote peers, implementing sophisticated buffering and flow control mechanisms.
 * 
 * @class NetronReadableStream
 * @extends Readable
 * @description Implements a reliable, ordered data stream for peer-to-peer communication
 */
export class NetronReadableStream extends Readable {
  /** The remote peer this stream is associated with */
  public readonly peer: RemotePeer;

  /** Internal buffer for storing out-of-order packets */
  private buffer: Map<number, any> = new Map();

  /** Next expected packet index for ordered delivery */
  private expectedIndex: number = 0;

  /** Timeout handle for stream inactivity detection */
  private timeout?: NodeJS.Timeout;

  /** Unique identifier for this stream */
  public readonly id: number;

  /** Whether the stream has been closed */
  private isClosed: boolean = false;

  /** Whether all data has been successfully received */
  public isComplete: boolean = false;

  /** Whether this is a live streaming connection */
  public isLive: boolean;

  /**
   * Creates a new NetronReadableStream instance.
   * 
   * @param {NetronReadableStreamOptions} options - Configuration options for the stream
   * @throws {Error} If stream initialization fails
   */
  constructor({ peer, streamId, isLive = false, ...opts }: NetronReadableStreamOptions) {
    super({ ...opts, objectMode: true });

    this.peer = peer;
    this.id = streamId;
    this.isLive = isLive;

    this.peer.readableStreams.set(this.id, this);

    if (!this.isLive) {
      this.resetTimeout();
    }

    this.on('close', this.cleanup);
    this.on('error', this.handleError);
  }

  /**
   * Processes incoming data packets and manages ordered delivery.
   * This method implements the core packet handling logic, including:
   * - Buffer overflow protection
   * - Packet reordering
   * - Flow control
   * - Stream completion detection
   * 
   * @param {Packet} packet - The incoming data packet
   * @returns {void}
   * @throws {Error} If buffer overflow occurs or stream is closed
   */
  public onPacket(packet: Packet): void {
    if (this.isClosed) return;

    this.resetTimeout();

    if (this.buffer.size > MAX_BUFFER_SIZE) {
      this.destroy(new Error(`Buffer overflow: more than ${MAX_BUFFER_SIZE} packets buffered`));
      return;
    }

    this.buffer.set(packet.streamIndex!, packet.data);

    while (this.buffer.has(this.expectedIndex)) {
      const chunk = this.buffer.get(this.expectedIndex);
      this.buffer.delete(this.expectedIndex);
      this.expectedIndex++;

      if (!this.push(chunk)) {
        // Internal buffer is full, wait for next 'readable' event
        break;
      }
    }

    if (packet.isLastChunk()) {
      this.isComplete = true;
      this.closeStream(true);
    }
  }

  /**
   * Implementation of the Readable stream's _read method.
   * This method is called when the stream's internal buffer is ready to accept more data.
   * In our implementation, data is pushed in onPacket, so this method is intentionally empty.
   * 
   * @returns {void}
   */
  override _read(): void {
    // Data is pushed in onPacket, no action needed here
  }

  /**
   * Resets the stream's inactivity timeout.
   * This method implements automatic stream cleanup for non-live streams
   * that have been inactive for too long.
   * 
   * @returns {void}
   */
  private resetTimeout(): void {
    if (this.isLive) return;

    if (this.timeout) clearTimeout(this.timeout);

    const timeoutDuration = this.peer.netron.options?.streamTimeout ?? 60000;

    this.timeout = setTimeout(() => {
      const message = `Stream ${this.id} inactive for ${timeoutDuration}ms, closing.`;
      console.warn(message);
      this.destroy(new Error(message));
    }, timeoutDuration);
  }

  /**
   * Closes the stream and releases associated resources.
   * This method implements graceful stream termination with support for
   * both normal and forced closure scenarios.
   * 
   * @param {boolean} [force=false] - Whether to force stream closure
   * @returns {void}
   */
  public closeStream(force: boolean = false): void {
    if (this.isClosed) return;

    if (this.isLive && !force) {
      console.warn(`Attempt to close live stream ${this.id}, operation ignored.`);
      return;
    }

    this.push(null);

    if (this.isLive && force) {
      this.destroy();
    }
  }

  /**
   * Performs cleanup operations when the stream is closed.
   * This method ensures proper resource deallocation and stream deregistration.
   * 
   * @returns {void}
   */
  private cleanup = (): void => {
    if (this.timeout) clearTimeout(this.timeout);
    this.peer.readableStreams.delete(this.id);
    this.buffer.clear();
  };

  /**
   * Handles stream error events.
   * This method implements error logging and cleanup for stream errors.
   * 
   * @param {Error} error - The error that occurred
   * @returns {void}
   */
  private handleError = (error: Error): void => {
    console.error(`NetronReadableStream (id: ${this.id}) error:`, error.message);
    this.cleanup();
  };

  /**
   * Overrides the standard destroy method to ensure proper cleanup.
   * This method implements a robust stream termination process that
   * guarantees resource cleanup and error propagation.
   * 
   * @param {Error} [error] - Optional error to propagate
   * @returns {this}
   */
  public override destroy(error?: Error): this {
    if (this.isClosed) return this;

    this.isClosed = true;
    super.destroy(error);
    this.cleanup();

    return this;
  }

  /**
   * Factory method for creating new NetronReadableStream instances.
   * This method provides a convenient way to create stream instances
   * with default configuration.
   * 
   * @param {RemotePeer} peer - The remote peer for this stream
   * @param {number} streamId - Unique identifier for the stream
   * @param {boolean} [isLive=false] - Whether this is a live stream
   * @returns {NetronReadableStream}
   */
  public static create(peer: RemotePeer, streamId: number, isLive: boolean = false): NetronReadableStream {
    return new NetronReadableStream({ peer, streamId, isLive });
  }
}

```

### File: src/reference.ts
```
/**
 * Represents a reference to a service definition within the Netron distributed system.
 * This class serves as a lightweight proxy that maintains a connection to a service
 * definition by its unique identifier. It is used extensively in the service discovery
 * and dependency injection mechanisms of the Netron framework.
 * 
 * @class Reference
 * @description A service definition reference that enables dynamic service resolution
 * and late binding in the Netron service architecture.
 * 
 * @example
 * // Creating a reference to a service definition
 * const serviceRef = new Reference('user-service-v1');
 * 
 * @see ServiceStub
 * @see Definition
 */
export class Reference {
  /**
   * Creates a new instance of Reference.
   * The constructor initializes a reference to a service definition using its unique identifier.
   * This identifier is used by the Netron framework to locate and resolve the actual service
   * definition when needed.
   * 
   * @param {string} defId - The unique identifier of the service definition.
   * This identifier must match the ID of an existing service definition in the Netron network.
   * 
   * @throws {Error} If the provided defId is not a valid string or is empty.
   * 
   * @example
   * // Creating a reference to a specific service
   * const authServiceRef = new Reference('authentication-service');
   */
  constructor(public defId: string) {
    if (!defId || typeof defId !== 'string') {
      throw new Error('Service definition ID must be a non-empty string');
    }
  }
}

```

### File: src/remote-peer.ts
```
/**
 * Imports required dependencies for the RemotePeer class implementation.
 * @module remote-peer
 */
import { WebSocket } from 'ws';
import { EventEmitter } from 'events';
import { TimedMap } from '@devgrid/common';

import { Netron } from './netron';
import { Interface } from './interface';
import { Definition } from './definition';
import { getQualifiedName } from './utils';
import { ServiceStub } from './service-stub';
import { AbstractPeer } from './abstract-peer';
import { StreamReference } from './stream-reference';
import { NetronReadableStream } from './readable-stream';
import { NetronWritableStream } from './writable-stream';
import { isServiceDefinition, isNetronStreamReference } from './predicates';
import { Abilities, NetronOptions, EventSubscriber, ServiceMetadata, ServiceExposeEvent, ServiceUnexposeEvent } from './types';
import {
  REQUEST_TIMEOUT,
  SERVICE_ANNOTATION,
  NETRON_EVENT_SERVICE_EXPOSE,
  NETRON_EVENT_SERVICE_UNEXPOSE,
} from './constants';
import {
  Packet,
  TYPE_GET,
  TYPE_SET,
  TYPE_CALL,
  TYPE_TASK,
  PacketType,
  TYPE_STREAM,
  createPacket,
  encodePacket,
  decodePacket,
  TYPE_STREAM_ERROR,
  createStreamPacket,
} from './packet';

/**
 * Represents a remote peer in the Netron network.
 * This class handles communication with a remote peer over WebSocket,
 * managing services, streams, and event subscriptions.
 * 
 * @class RemotePeer
 * @extends AbstractPeer
 */
export class RemotePeer extends AbstractPeer {
  /** Event emitter for handling internal events */
  private events = new EventEmitter();

  /**
   * Map of response handlers for pending requests with timeout functionality.
   * Each handler contains success and error callbacks.
   */
  private responseHandlers = new TimedMap<
    number,
    { successHandler: (response: Packet) => void; errorHandler?: (data: any) => void }
  >(this.netron.options?.requestTimeout ?? REQUEST_TIMEOUT, (packetId: number) => {
    const handlers = this.deleteResponseHandler(packetId);
    if (handlers?.errorHandler) {
      handlers.errorHandler(new Error('Request timeout exceeded'));
    }
  });

  /** Map of writable streams indexed by stream ID */
  public writableStreams = new Map<number, NetronWritableStream>();

  /** Map of readable streams indexed by stream ID */
  public readableStreams = new Map<number, NetronReadableStream>();

  /** Map of event subscribers indexed by event name */
  public eventSubscribers = new Map<string, EventSubscriber[]>();

  /** Map of remote subscriptions indexed by event name */
  public remoteSubscriptions = new Map<string, EventSubscriber>();

  /** Map of service definitions indexed by service name */
  public services = new Map<string, Definition>();

  /** Map of all definitions indexed by definition ID */
  public definitions = new Map<string, Definition>();

  /**
   * Creates a new instance of RemotePeer.
   * 
   * @constructor
   * @param {WebSocket} socket - The WebSocket connection to the remote peer
   * @param {Netron} netron - The Netron instance this peer belongs to
   * @param {string} [id=""] - Optional unique identifier for the remote peer
   */
  constructor(
    private socket: WebSocket,
    netron: Netron,
    id: string = ''
  ) {
    super(netron, id);
  }

  /**
   * Initializes the remote peer connection.
   * Sets up message handlers and initializes service discovery if acting as a connector.
   * 
   * @async
   * @param {boolean} [isConnector] - Whether this peer is acting as a connector
   * @param {NetronOptions} [options] - Configuration options for the local Netron instance
   * @returns {Promise<void>}
   */
  async init(isConnector?: boolean, options?: NetronOptions) {
    // Set up WebSocket message handler
    this.socket.on('message', (data: ArrayBuffer, isBinary: boolean) => {
      if (isBinary) {
        try {
          this.handlePacket(decodePacket(data));
        } catch (error) {
          console.error('Packet decode error:', error);
        }
      } else {
        console.warn('Received non-binary message:', data);
      }
    });

    // Initialize service discovery if acting as connector
    if (isConnector) {
      // Get remote peer's abilities
      this.abilities = (await this.runTask('abilities', this.netron.peer.abilities)) as Abilities;

      // Register available services
      if (this.abilities.services) {
        for (const [name, definition] of this.abilities.services) {
          this.definitions.set(definition.id, definition);
          this.services.set(name, definition);
        }
      }

      // Subscribe to service lifecycle events if supported
      if (this.abilities.allowServiceEvents) {
        await this.subscribe(NETRON_EVENT_SERVICE_EXPOSE, (event: ServiceExposeEvent) => {
          this.definitions.set(event.definition.id, event.definition);
          this.services.set(event.qualifiedName, event.definition);
        });
        await this.subscribe(NETRON_EVENT_SERVICE_UNEXPOSE, (event: ServiceUnexposeEvent) => {
          this.definitions.delete(event.defId);
          this.services.delete(event.qualifiedName);
        });
      }
    }
  }

  /**
   * Exposes a service to the remote peer.
   * Validates the service metadata and creates necessary stubs.
   * 
   * @async
   * @param {any} instance - The service instance to expose
   * @returns {Promise<Definition>} The service definition
   * @throws {Error} If the service is invalid or already exposed
   */
  async exposeService(instance: any) {
    const meta = Reflect.getMetadata(SERVICE_ANNOTATION, instance.constructor) as ServiceMetadata;
    if (!meta) {
      throw new Error('Invalid service');
    }

    if (this.services.has(meta.name)) {
      throw new Error(`Service already exposed: ${meta.name}`);
    }

    const def = await this.runTask('expose_service', meta);

    const stub = new ServiceStub(this.netron.peer, instance, meta);
    this.netron.peer.stubs.set(def.id, stub);
    this.netron.peer.serviceInstances.set(instance, stub);

    return def;
  }

  /**
   * Unexposes a service from the remote peer.
   * Cleans up associated interfaces and stubs.
   * 
   * @async
   * @param {string} serviceName - The name of the service to unexpose
   * @returns {Promise<void>}
   */
  async unexposeService(serviceName: string) {
    const defId = await this.runTask('unexpose_service', serviceName);

    // Clean up interfaces
    for (const i of this.interfaces.values()) {
      if (i.instance.$def?.parentId === defId) {
        this.releaseInterface(i.instance);
      }
    }

    // Clean up stubs
    const stub = this.netron.peer.stubs.get(defId);
    if (stub) {
      this.netron.peer.serviceInstances.delete(stub.instance);
      this.netron.peer.stubs.delete(defId);
    }
  }

  /**
   * Subscribes to an event from the remote peer.
   * 
   * @async
   * @param {string} eventName - The name of the event to subscribe to
   * @param {EventSubscriber} handler - The event handler function
   * @returns {Promise<void>}
   */
  async subscribe(eventName: string, handler: EventSubscriber) {
    const handlers = this.eventSubscribers.get(eventName);
    if (!handlers) {
      this.eventSubscribers.set(eventName, [handler]);
      await this.runTask('subscribe', eventName);
    } else if (!handlers.includes(handler)) {
      handlers.push(handler);
    }
  }

  /**
   * Unsubscribes from an event.
   * 
   * @async
   * @param {string} eventName - The name of the event to unsubscribe from
   * @param {EventSubscriber} handler - The event handler to remove
   * @returns {Promise<void>}
   */
  async unsubscribe(eventName: string, handler: EventSubscriber) {
    const handlers = this.eventSubscribers.get(eventName);
    if (handlers) {
      const index = handlers.indexOf(handler);
      if (index >= 0) {
        handlers.splice(index, 1);
        if (handlers.length === 0) {
          this.eventSubscribers.delete(eventName);
          await this.runTask('unsubscribe', eventName);
        }
      }
    }
  }

  /**
   * Gets the names of all available services.
   * 
   * @returns {string[]} Array of service names
   */
  getServiceNames() {
    return [...this.services.keys()];
  }

  /**
   * Gets a value from a service definition.
   * 
   * @param {string} defId - The service definition ID
   * @param {string} defId - The unique identifier of the service definition.
   * @param {string} name - The name of the value to get.
   * @returns {Promise<any>} The value.
   */
  get(defId: string, name: string) {
    const def = this.definitions.get(defId);
    if (!def) {
      throw new Error(`Unknown definition: ${defId}`);
    }

    return new Promise<any>((resolve, reject) => {
      this.sendRequest(
        TYPE_GET,
        [defId, name],
        (result) => {
          resolve(this.processResult(def, result));
        },
        reject
      ).catch(reject);
    });
  }
  /**
   * Sets a value in a service definition.
   * This method allows setting a property value on a remote service instance.
   * It first validates that the service definition exists, then sends a request
   * to the remote peer to update the value.
   * 
   * @param {string} defId - The unique identifier of the service definition to update
   * @param {string} name - The name of the property to set
   * @param {any} value - The new value to assign to the property
   * @returns {Promise<void>} A promise that resolves when the value has been set
   * @throws {Error} If the service definition is not found
   */
  set(defId: string, name: string, value: any) {
    const def = this.definitions.get(defId);
    if (!def) {
      throw new Error(`Unknown definition: ${defId}`);
    }

    return new Promise<void>((resolve, reject) => {
      this.sendRequest(
        TYPE_SET,
        [defId, name, value],
        () => {
          resolve();
        },
        reject
      ).catch(reject);
    });
  }

  /**
   * Calls a method on a service definition.
   * This method invokes a remote procedure call on a service instance.
   * It processes the arguments, sends the request, and handles the response.
   * 
   * @param {string} defId - The unique identifier of the service definition
   * @param {string} method - The name of the method to invoke
   * @param {any[]} args - The arguments to pass to the method
   * @returns {Promise<any>} A promise that resolves with the method's return value
   * @throws {Error} If the service definition is not found
   */
  call(defId: string, method: string, args: any[]) {
    const def = this.definitions.get(defId);
    if (!def) {
      throw new Error(`Unknown definition: ${defId}`);
    }

    args = this.processArgs(def, args);
    return new Promise<any>((resolve, reject) => {
      this.sendRequest(
        TYPE_CALL,
        [defId, method, ...args],
        (result) => {
          resolve(this.processResult(def, result));
        },
        reject
      ).catch(reject);
    });
  }

  /**
   * Disconnects the remote peer connection.
   * This method gracefully closes the WebSocket connection and cleans up resources.
   * It emits a 'manual-disconnect' event and performs cleanup operations.
   */
  disconnect() {
    this.events.emit('manual-disconnect');

    if (this.socket.readyState === WebSocket.OPEN || this.socket.readyState === WebSocket.CONNECTING) {
      this.socket.close();
    } else {
      console.warn(`Attempt to close WebSocket in unexpected state: ${this.socket.readyState}`);
    }
    this.cleanup();
  }

  /**
   * Registers a one-time event listener.
   * This method allows listening for specific events that will only trigger once.
   * 
   * @param {'manual-disconnect' | 'stream'} event - The event name to listen for
   * @param {(...args: any[]) => void} listener - The callback function to execute
   */
  once(event: 'manual-disconnect' | 'stream', listener: (...args: any[]) => void) {
    this.events.once(event, listener);
  }

  /**
   * Cleans up internal resources and state.
   * This method clears all internal maps and collections used for managing
   * connections, streams, and service definitions.
   */
  private cleanup() {
    this.responseHandlers.clear();
    this.writableStreams.clear();
    this.readableStreams.clear();
    this.eventSubscribers.clear();
    this.remoteSubscriptions.clear();
    this.services.clear();
    this.definitions.clear();
  }

  /**
   * Executes a task on the remote peer.
   * This method sends a task request to the remote peer and handles the response.
   * 
   * @param {string} name - The name of the task to execute
   * @param {...any[]} args - Variable number of arguments to pass to the task
   * @returns {Promise<any>} A promise that resolves with the task's result
   */
  runTask(name: string, ...args: any[]) {
    return new Promise<any>((resolve, reject) => {
      this.sendRequest(
        TYPE_TASK,
        [name, ...args],
        (result) => {
          resolve(result);
        },
        reject
      ).catch(reject);
    });
  }

  /**
   * Sends a request to the remote peer.
   * This method creates a new packet, registers response handlers, and sends it.
   * 
   * @param {PacketType} type - The type of packet to send
   * @param {any} data - The data payload to include in the packet
   * @param {(response: Packet) => void} successHandler - Callback for successful responses
   * @param {(data: any) => void} [errorHandler] - Optional callback for error responses
   * @returns {Promise<void>} A promise that resolves when the packet is sent
   */
  private sendRequest(
    type: PacketType,
    data: any,
    successHandler: (response: Packet) => void,
    errorHandler?: (data: any) => void
  ) {
    const packet = createPacket(Packet.nextId(), 1, type, data);
    this.responseHandlers.set(packet.id, {
      successHandler,
      errorHandler,
    });

    return this.sendPacket(packet);
  }

  /**
   * Sends a response packet to the remote peer.
   * This method prepares and sends a response packet with the specified data.
   * 
   * @param {Packet} packet - The original packet to respond to
   * @param {any} data - The response data to send
   * @returns {Promise<void>} A promise that resolves when the response is sent
   */
  private sendResponse(packet: Packet, data: any) {
    packet.setImpulse(0);
    packet.data = data;
    return this.sendPacket(packet);
  }

  /**
   * Sends an error response to the remote peer.
   * This method prepares and sends an error response packet.
   * 
   * @param {Packet} packet - The original packet to respond to
   * @param {any} error - The error information to send
   * @returns {Promise<void>} A promise that resolves when the error response is sent
   */
  private sendErrorResponse(packet: Packet, error: any) {
    packet.setImpulse(0);
    packet.setError(1);
    packet.data = error;
    return this.sendPacket(packet);
  }

  /**
   * Sends a packet to the remote peer.
   * This method handles the actual transmission of packets over the WebSocket connection.
   * 
   * @param {Packet} packet - The packet to send
   * @returns {Promise<void>} A promise that resolves when the packet is sent
   * @throws {Error} If the WebSocket connection is not open
   */
  sendPacket(packet: Packet) {
    return new Promise<void>((resolve, reject) => {
      if (this.socket.readyState === WebSocket.OPEN) {
        this.socket.send(encodePacket(packet), { binary: true }, (err) => {
          if (err) {
            reject(err);
          } else {
            resolve();
          }
        });
      } else {
        reject(new Error('Socket closed'));
      }
    });
  }

  /**
   * Sends a stream chunk to the remote peer.
   * This method sends a portion of stream data to the remote peer.
   * 
   * @param {number} streamId - The unique identifier of the stream
   * @param {any} chunk - The data chunk to send
   * @param {number} index - The sequence number of the chunk
   * @param {boolean} isLast - Whether this is the final chunk in the stream
   * @param {boolean} isLive - Whether this is a live streaming chunk
   * @returns {Promise<void>} A promise that resolves when the chunk is sent
   */
  sendStreamChunk(streamId: number, chunk: any, index: number, isLast: boolean, isLive: boolean) {
    return this.sendPacket(createStreamPacket(Packet.nextId(), streamId, index, isLast, isLive, chunk));
  }

  /**
   * Handles a response packet from the remote peer.
   * This method processes incoming response packets and invokes the appropriate handlers.
   * 
   * @param {Packet} packet - The response packet to handle
   */
  private handleResponse(packet: Packet) {
    const id = packet.id;
    const handlers = this.deleteResponseHandler(id);
    if (handlers) {
      const data = packet.data;
      if (packet.getError() === 0) {
        handlers.successHandler(data);
      } else {
        handlers.errorHandler?.(data);
      }
    }
  }
  /**
   * Handles incoming packets from the remote peer.
   * This method serves as the central packet processing hub, routing different types of packets
   * to their appropriate handlers. It implements a robust error handling mechanism and supports
   * various packet types including SET, GET, CALL, TASK, STREAM, and STREAM_ERROR operations.
   * 
   * @param {Packet} packet - The incoming packet to be processed
   * @returns {Promise<void>} Resolves when packet processing is complete
   * @throws {Error} If packet processing fails and error response cannot be sent
   */
  async handlePacket(packet: Packet) {
    const pType = packet.getType();

    // Handle response packets immediately
    if (packet.getImpulse() === 0) {
      this.handleResponse(packet);
      return;
    }

    // Process different packet types
    switch (pType) {
      case TYPE_SET: {
        const [defId, name, value] = packet.data;

        try {
          const stub = this.netron.peer.getStubByDefinitionId(defId);
          await stub.set(name, value);
          await this.sendResponse(packet, undefined);
        } catch (err: any) {
          console.error('Error setting value:', err);
          try {
            await this.sendErrorResponse(packet, err);
          } catch (err_: any) {
            console.error('Error sending error response:', err_);
          }
        }
        break;
      }
      case TYPE_GET: {
        const [defId, name] = packet.data;

        try {
          const stub = this.netron.peer.getStubByDefinitionId(defId);
          await this.sendResponse(packet, await stub.get(name));
        } catch (err: any) {
          try {
            await this.sendErrorResponse(packet, err);
          } catch (err_) {
            console.error('Error sending error response:', err_);
          }
        }
        break;
      }
      case TYPE_CALL: {
        const [defId, method, ...args] = packet.data;

        try {
          const stub = this.netron.peer.getStubByDefinitionId(defId);
          await this.sendResponse(packet, await stub.call(method, args));
        } catch (err: any) {
          try {
            await this.sendErrorResponse(packet, err);
          } catch (err_) {
            console.error('Error sending error response:', err_);
          }
        }
        break;
      }
      case TYPE_TASK: {
        const [name, ...args] = packet.data;
        try {
          await this.sendResponse(packet, await this.netron.runTask(this, name, ...args));
        } catch (err: any) {
          try {
            await this.sendErrorResponse(packet, err);
          } catch (err_) {
            console.error('Error sending error response:', err_);
          }
        }
        break;
      }
      case TYPE_STREAM: {
        if (!packet.streamId) return;

        let stream = this.readableStreams.get(packet.streamId);
        if (!stream) {
          stream = NetronReadableStream.create(this, packet.streamId, packet.isLive());
          this.events.emit('stream', stream);
        }

        stream.onPacket(packet);
        break;
      }
      case TYPE_STREAM_ERROR: {
        const { streamId, message } = packet.data;
        const stream = this.readableStreams.get(streamId);
        if (stream) {
          stream.destroy(new Error(message));
        }
        break;
      }
      default: {
        console.warn('Unknown packet type:', pType);
      }
    }
  }

  /**
   * Releases an interface instance and its associated resources.
   * This method performs cleanup operations by unreferencing the service
   * and removing it from the internal service registry.
   * 
   * @param {Interface} iInstance - The interface instance to be released
   * @returns {Promise<void>} Resolves when the interface is fully released
   */
  protected async releaseInterfaceInternal(iInstance: Interface) {
    await this.runTask('unref_service', iInstance.$def?.id);
    this.unrefService(iInstance.$def?.id);
  }

  /**
   * References a service definition and establishes its relationship with a parent service.
   * This method manages service definition references and maintains the service hierarchy.
   * 
   * @param {Definition} def - The service definition to be referenced
   * @param {Definition} parentDef - The parent service definition
   * @returns {Definition} The referenced service definition
   */
  refService(def: Definition, parentDef: Definition) {
    const existingDef = this.definitions.get(def.id);
    if (existingDef) {
      return existingDef;
    }

    def.parentId = parentDef.id;
    this.definitions.set(def.id, def);
    return def;
  }

  /**
   * Unreferences a service definition and removes it from the registry if no longer needed.
   * This method performs cleanup of unused service definitions to prevent memory leaks.
   * 
   * @param {string} [defId] - The unique identifier of the service definition to unreference
   */
  unrefService(defId?: string) {
    if (defId) {
      const def = this.definitions.get(defId);
      if (def) {
        if (!this.services.has(getQualifiedName(def.meta.name, def.meta.version))) {
          this.definitions.delete(defId);
        }
      }
    }
  }

  /**
   * Processes the result of a service call, handling special types like service definitions
   * and stream references. This method ensures proper type conversion and reference management.
   * 
   * @param {Definition} parentDef - The parent service definition context
   * @param {any} result - The raw result to be processed
   * @returns {any} The processed result with proper type conversion
   */
  private processResult(parentDef: Definition, result: any) {
    if (isServiceDefinition(result)) {
      const def = this.refService(result, parentDef);
      return this.queryInterfaceByDefId(def.id, def);
    } else if (isNetronStreamReference(result)) {
      return StreamReference.to(result, this);
    }
    return result;
  }

  /**
   * Processes arguments before sending them to the remote peer.
   * This method can be overridden to implement custom argument processing logic.
   * 
   * @param {Definition} ctxDef - The context service definition
   * @param {any} args - The arguments to be processed
   * @returns {any} The processed arguments
   */
  private processArgs(ctxDef: Definition, args: any) {
    return args;
  }

  /**
   * Deletes a response handler for a specific packet ID.
   * This method manages the lifecycle of response handlers and cleans up resources.
   * 
   * @param {number} packetId - The unique identifier of the packet
   * @returns {any} The deleted response handler, if it exists
   */
  private deleteResponseHandler(packetId: number) {
    const handlers = this.responseHandlers.get(packetId);
    if (handlers) {
      this.responseHandlers.delete(packetId);
    }
    return handlers;
  }

  /**
   * Retrieves a service definition by its unique identifier.
   * This method provides access to service definitions while ensuring they exist.
   * 
   * @param {string} defId - The unique identifier of the service definition
   * @returns {Definition} The requested service definition
   * @throws {Error} If the service definition cannot be found
   */
  protected getDefinitionById(defId: string) {
    const def = this.definitions.get(defId);
    if (!def) {
      throw new Error(`Unknown definition: ${defId}.`);
    }
    return def;
  }

  /**
   * Retrieves a service definition by its qualified name.
   * This method provides access to service definitions using their service names.
   * 
   * @param {string} name - The qualified name of the service
   * @returns {Definition} The requested service definition
   * @throws {Error} If the service definition cannot be found
   */
  protected getDefinitionByServiceName(name: string) {
    const def = this.services.get(name);
    if (def === void 0) {
      throw new Error(`Unknown service: ${name}.`);
    }
    return def;
  }
}

```

### File: src/service-discovery/index.ts
```
export * from './types';
export * from './service-discovery';
```

### File: src/service-discovery/service-discovery.ts
```
import fs from 'node:fs';
import path from 'node:path';
import { Redis } from 'ioredis';

import { NodeInfo, ServiceInfo, DiscoveryEvent, DiscoveryOptions } from './types';

/**
 * Default interval in milliseconds for sending periodic heartbeat signals to Redis.
 * This interval determines how frequently a node updates its presence in the discovery system.
 */
const DEFAULT_HEARTBEAT_INTERVAL = 5000;

/**
 * Default Time-To-Live (TTL) in milliseconds for heartbeat keys in Redis.
 * If a node fails to update its heartbeat within this period, it will be considered inactive
 * and automatically deregistered from the discovery system.
 */
const DEFAULT_HEARTBEAT_TTL = 15000;

/**
 * Lua script for atomic registration of node heartbeats in Redis.
 * The script is loaded from the filesystem and executed as a single transaction.
 */
const REGISTER_HEARTBEAT_SCRIPT = fs.readFileSync(path.join(__dirname, '../../lua/register-heartbeat.lua'), 'utf8');

/**
 * ServiceDiscovery class implements a distributed service discovery mechanism using Redis
 * as a coordination backend. It provides functionality for:
 * - Node registration and heartbeat management
 * - Service discovery and lookup
 * - Automatic cleanup of inactive nodes
 * - Dynamic service and address updates
 * 
 * @remarks
 * The implementation uses Redis keys with the following patterns:
 * - `netron:discovery:nodes:{nodeId}` - Hash containing node metadata
 * - `netron:discovery:heartbeat:{nodeId}` - Key indicating node liveness
 * - `netron:discovery:index:nodes` - Set containing all registered node IDs
 */
export class ServiceDiscovery {
  /** Redis client instance used for all coordination operations */
  private redis: Redis;

  /** Globally unique identifier for this node instance */
  private nodeId: string;

  /** Network address where this node can be reached */
  private address: string;

  /** Array of services provided by this node */
  private services: ServiceInfo[];

  /** Reference to the interval timer for periodic heartbeat updates */
  private heartbeatTimer?: NodeJS.Timeout;

  /** Configuration options with default values applied */
  private options: Required<DiscoveryOptions>;
  /**
   * Redis PubSub channel name used for broadcasting service discovery events.
   * This channel is used to notify other nodes about changes in the service discovery system,
   * such as node registration, deregistration, or service updates.
   * 
   * @private
   * @readonly
   */
  private readonly pubSubChannel: string;

  /**
   * Redis subscriber instance for receiving PubSub events.
   * This subscriber is used to listen for service discovery events from other nodes
   * and react to changes in the distributed system state.
   * 
   * @private
   * @optional
   */
  private subscriber?: Redis;

  /**
   * Flag indicating whether the service discovery instance has been stopped.
   * This flag is used to prevent operations after shutdown and ensure
   * proper cleanup of resources.
   * 
   * @private
   */
  private stopped = false;

  /**
   * Promise that resolves when the shutdown process is complete.
   * This promise is used to coordinate graceful shutdown operations
   * and ensure all resources are properly cleaned up before the instance
   * is considered fully stopped.
   * 
   * @private
   * @optional
   */
  private shutdownPromise?: Promise<void>;
  /**
   * Flag indicating whether the current node has been successfully registered in the service discovery system.
   * This flag is used to track the registration state of the node and prevent duplicate registrations.
   * 
   * @private
   * @type {boolean}
   * 
   * @remarks
   * The registration state is managed as follows:
   * - Set to true after successful initial registration
   * - Set to false when the node is deregistered or during shutdown
   * - Used to prevent duplicate registration attempts
   * - Helps maintain consistency in the distributed system state
   * 
   * @example
   * // Checking registration status
   * if (!this.registered) {
   *   await this.registerNode();
   * }
   */
  private registered = false;

  /**
   * Constructs a new ServiceDiscovery instance with the specified configuration
   * 
   * @param redis - Redis client instance for distributed coordination
   * @param nodeId - Unique identifier for this node instance
   * @param address - Network address where this node can be reached
   * @param services - Array of services provided by this node
   * @param options - Optional configuration overrides for discovery behavior
   * 
   * @remarks
   * The constructor applies default values for heartbeat interval and TTL if not specified.
   * These defaults ensure reasonable behavior while allowing customization when needed.
   */
  constructor(redis: Redis, nodeId: string, address: string, services: ServiceInfo[], options?: DiscoveryOptions) {
    if (!redis) {
      throw new Error('Redis instance must be provided');
    }

    this.redis = redis;
    this.nodeId = nodeId;
    this.address = address;
    this.services = services;
    this.options = {
      heartbeatInterval: options?.heartbeatInterval ?? DEFAULT_HEARTBEAT_INTERVAL,
      heartbeatTTL: options?.heartbeatTTL ?? DEFAULT_HEARTBEAT_TTL,
      pubSubEnabled: options?.pubSubEnabled ?? false,
      pubSubChannel: options?.pubSubChannel ?? 'netron:discovery:events',
    };

    this.pubSubChannel = this.options.pubSubChannel;
  }

  /**
   * Initiates the heartbeat mechanism for this node
   * 
   * @remarks
   * This method performs two key operations:
   * 1. Immediately publishes the initial heartbeat
   * 2. Sets up a periodic timer to maintain node registration
   * 
   * The heartbeat interval is determined by the configured options.
   */
  public startHeartbeat(): void {
    this.publishHeartbeat();
    this.heartbeatTimer = setInterval(
      () => this.publishHeartbeat(),
      this.options.heartbeatInterval
    );
  }

  /**
   * Initiates a graceful shutdown sequence for the service discovery instance.
   * This method ensures proper cleanup of all resources and deregistration from the network.
   * 
   * @returns {Promise<void>} A promise that resolves when the shutdown sequence is complete.
   *                         If shutdown was already initiated, returns the existing shutdown promise.
   * 
   * @remarks
   * The shutdown sequence is idempotent and follows a specific order:
   * 1. Checks if shutdown was already initiated to prevent duplicate operations
   * 2. Stops the heartbeat mechanism by clearing the interval timer
   * 3. Deregisters the node from the discovery system
   * 4. Unsubscribes from Redis Pub/Sub events
   * 
   * Error Handling:
   * - Each major operation is wrapped in a try-catch block
   * - Errors are logged but don't prevent the shutdown sequence from continuing
   * - The method maintains a single shutdown promise to ensure consistent state
   * 
   * State Management:
   * - Sets the 'stopped' flag to prevent further operations
   * - Resets the 'registered' state after successful deregistration
   * - Cleans up all timer and subscription resources
   * 
   * @example
   * // Initiating a graceful shutdown
   * await serviceDiscovery.shutdown();
   * 
   * @throws {Error} If the shutdown sequence encounters critical errors
   *                that prevent proper cleanup
   */
  public async shutdown(): Promise<void> {
    if (this.stopped) {
      console.info(`Graceful shutdown already initiated for node '${this.nodeId}'`);
      return this.shutdownPromise;
    }

    this.stopped = true;

    this.shutdownPromise = (async () => {
      console.info(`Initiating graceful shutdown for node '${this.nodeId}'`);

      // Stop the heartbeat mechanism
      if (this.heartbeatTimer) {
        clearInterval(this.heartbeatTimer);
        this.heartbeatTimer = undefined;
        console.info(`Heartbeat interval cleared for node '${this.nodeId}'`);
      }

      // Deregister the node from the discovery system
      try {
        await this.deregisterNodeById(this.nodeId);
        this.registered = false; // Reset registration state
        console.info(`Node '${this.nodeId}' successfully deregistered`);
      } catch (error) {
        console.error(`Error during deregistration of node '${this.nodeId}'`, { error });
      }

      // Clean up Redis Pub/Sub subscriptions
      try {
        await this.unsubscribeFromEvents();
        console.info(`Unsubscribed from Redis events for node '${this.nodeId}'`);
      } catch (error) {
        console.error(`Error during Redis Pub/Sub unsubscribe for node '${this.nodeId}'`, { error });
      }

      console.info(`Graceful shutdown completed for node '${this.nodeId}'`);
    })();

    return this.shutdownPromise;
  }

  /**
   * Publishes a heartbeat signal to Redis using a Lua script to maintain node presence in the discovery system.
   * 
   * @returns {Promise<void>} A promise that resolves when the heartbeat is successfully published
   * 
   * @throws {Error} If all retry attempts fail to publish the heartbeat
   * 
   * @remarks
   * The heartbeat mechanism is crucial for maintaining node presence in the distributed system.
   * This method implements a robust retry mechanism with exponential backoff to handle transient failures.
   * 
   * The heartbeat operation is performed atomically using a Lua script that:
   * 1. Updates the node's metadata hash with current information (address, services, timestamp)
   * 2. Sets the heartbeat key with the configured TTL to indicate node liveness
   * 3. Adds the node to the global index if not already present
   * 
   * Event Publishing:
   * - On first successful heartbeat: NODE_REGISTERED event
   * - On subsequent heartbeats: NODE_UPDATED event
   * 
   * Retry Strategy:
   * - Maximum of 3 retry attempts
   * - Exponential backoff delay between attempts (500ms * attempt number)
   * - Detailed logging of retry attempts and failures
   * 
   * @example
   * // Publishing a heartbeat with automatic retries
   * await serviceDiscovery.publishHeartbeat();
   */
  public async publishHeartbeat(): Promise<void> {
    // Prevent heartbeat publishing if shutdown has been initiated
    if (this.stopped) {
      console.warn(`Attempted to publish heartbeat after shutdown initiated for node '${this.nodeId}'`);
      return;
    }

    // Define Redis keys for node metadata, heartbeat, and global index
    const nodeKey = `netron:discovery:nodes:${this.nodeId}`;
    const heartbeatKey = `netron:discovery:heartbeat:${this.nodeId}`;
    const nodesIndexKey = 'netron:discovery:index:nodes';

    // Implement retry mechanism with exponential backoff
    const maxRetries = 3;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        // Execute the Lua script with all required parameters
        await this.redis.eval(
          REGISTER_HEARTBEAT_SCRIPT,
          3,
          nodeKey,
          heartbeatKey,
          nodesIndexKey,
          this.nodeId,
          this.address,
          JSON.stringify(this.services),
          Date.now().toString(),
          Math.ceil(this.options.heartbeatTTL / 1000).toString(),
          this.options.heartbeatTTL.toString()
        );

        // Determine event type based on registration status
        const eventType = this.registered ? 'NODE_UPDATED' : 'NODE_REGISTERED';

        // Update registration status on first successful heartbeat
        if (!this.registered) {
          this.registered = true;
        }

        // Log successful retry if applicable
        if (attempt > 1) {
          console.info(`Heartbeat succeeded after ${attempt} attempts`);
        }

        // Publish the appropriate event
        await this.publishEvent(eventType);
        return;
      } catch (error) {
        // Log failure and implement retry logic
        console.error(`Heartbeat attempt ${attempt} failed`, { error });

        if (attempt === maxRetries) {
          console.error(`All ${maxRetries} heartbeat attempts failed.`);
          throw error;
        }

        // Implement exponential backoff delay
        await new Promise((res) => setTimeout(res, 500 * attempt));
      }
    }
  }

  /**
   * Retrieves information about all currently active nodes
   * 
   * @returns Promise that resolves to an array of NodeInfo objects
   * 
   * @remarks
   * This method implements a robust node discovery process:
   * 1. Retrieves all node IDs from the global index
   * 2. Uses Redis pipeline to efficiently fetch node data and heartbeat status
   * 3. Validates and parses node information
   * 4. Automatically cleans up inactive or invalid nodes
   * 
   * The method handles various edge cases including:
   * - Missing or corrupted node data
   * - Invalid JSON in service descriptions
   * - Missing heartbeat keys
   */
  public async getActiveNodes(): Promise<NodeInfo[]> {
    try {
      const nodeIds = await this.redis.smembers('netron:discovery:index:nodes');
      if (!nodeIds.length) return [];

      const pipeline = this.redis.pipeline();

      nodeIds.forEach((id) => {
        pipeline.hgetall(`netron:discovery:nodes:${id}`);
        pipeline.exists(`netron:discovery:heartbeat:${id}`);
      });

      const results = await pipeline.exec();

      const activeNodes: NodeInfo[] = [];
      const nodesToDeregister: string[] = [];

      if (!results) return activeNodes;

      for (let i = 0; i < nodeIds.length; i++) {
        const nodeId = nodeIds[i];
        if (!nodeId) continue;

        const nodeDataResult = results[i * 2];
        const heartbeatResult = results[i * 2 + 1];

        if (!nodeDataResult || !heartbeatResult) {
          nodesToDeregister.push(nodeId);
          continue;
        }

        const [nodeDataErr, nodeData] = nodeDataResult;
        const [heartbeatErr, heartbeatExists] = heartbeatResult;

        if (
          nodeDataErr ||
          heartbeatErr ||
          !heartbeatExists ||
          !nodeData ||
          typeof nodeData !== 'object'
        ) {
          nodesToDeregister.push(nodeId);
          continue;
        }

        const address = typeof nodeData['address'] === 'string' ? nodeData['address'] : null;
        const servicesRaw = typeof nodeData['services'] === 'string' ? nodeData['services'] : null;
        const timestampRaw = typeof nodeData['timestamp'] === 'string' ? nodeData['timestamp'] : null;

        if (!address || !servicesRaw || !timestampRaw) {
          nodesToDeregister.push(nodeId);
          continue;
        }

        let services: ServiceInfo[];
        try {
          services = JSON.parse(servicesRaw);
        } catch {
          nodesToDeregister.push(nodeId);
          continue;
        }

        activeNodes.push({
          nodeId,
          address,
          services,
          timestamp: Number(timestampRaw),
        });
      }

      if (nodesToDeregister.length > 0) {
        const deregisterPipeline = this.redis.pipeline();
        nodesToDeregister.forEach((id) => {
          deregisterPipeline
            .del(`netron:discovery:nodes:${id}`)
            .del(`netron:discovery:heartbeat:${id}`)
            .srem('netron:discovery:index:nodes', id);
        });
        await deregisterPipeline.exec();
      }

      return activeNodes;
    } catch (error) {
      console.error(`Error fetching active nodes`, { error });
      throw error;
    }
  }

  /**
   * Discovers nodes that provide a specific service within the distributed network.
   * This method performs a filtered search across all active nodes to find those
   * that match the specified service criteria.
   * 
   * @param {string} name - The unique identifier of the service to search for
   * @param {string} [version] - Optional version constraint to filter service providers.
   *                            If specified, only nodes providing the exact version will be returned.
   * @returns {Promise<NodeInfo[]>} A promise that resolves to an array of NodeInfo objects,
   *                               each representing a node that provides the requested service.
   *                               The array will be empty if no matching nodes are found.
   * 
   * @example
   * // Find all nodes providing the 'auth' service
   * const authNodes = await discovery.findNodesByService('auth');
   * 
   * // Find nodes providing version 1.0.0 of the 'auth' service
   * const specificAuthNodes = await discovery.findNodesByService('auth', '1.0.0');
   */
  public async findNodesByService(name: string, version?: string): Promise<NodeInfo[]> {
    try {
      const activeNodes = await this.getActiveNodes();
      return activeNodes.filter(node =>
        node.services.some(svc =>
          svc.name === name && (!version || svc.version === version)
        )
      );
    } catch (error) {
      console.error(`Error finding nodes by service '${name}' (version: ${version})`, { error });
      throw error;
    }
  }

  /**
   * Subscribes to service discovery events published through Redis PubSub.
   * This method establishes a dedicated Redis subscriber connection and sets up
   * event handling for service discovery notifications.
   * 
   * @param {function} handler - Callback function that processes incoming discovery events.
   *                            The handler receives a parsed DiscoveryEvent object containing
   *                            details about node registration, updates, or deregistration.
   * @returns {Promise<void>} A promise that resolves when the subscription is established.
   * 
   * @remarks
   * The subscription process:
   * 1. Validates that PubSub is enabled and the instance hasn't been stopped
   * 2. Creates a new Redis subscriber instance with the same configuration as the main client
   * 3. Subscribes to the configured PubSub channel
   * 4. Sets up message handling with error protection and state validation
   * 
   * @throws {Error} If Redis subscription fails
   * 
   * @example
   * // Subscribing to service discovery events
   * await discovery.subscribeToEvents((event) => {
   *   switch (event.type) {
   *     case 'NODE_REGISTERED':
   *       console.log(`New node registered: ${event.nodeId}`);
   *       break;
   *     case 'NODE_UPDATED':
   *       console.log(`Node updated: ${event.nodeId}`);
   *       break;
   *     case 'NODE_DEREGISTERED':
   *       console.log(`Node deregistered: ${event.nodeId}`);
   *       break;
   *   }
   * });
   */
  public async subscribeToEvents(handler: (event: DiscoveryEvent) => void): Promise<void> {
    // Early return if PubSub is disabled or instance is stopped
    if (!this.options.pubSubEnabled || this.stopped) return;

    // Create a new Redis subscriber instance with the same configuration
    this.subscriber = new Redis(this.redis.options);

    // Subscribe to the configured PubSub channel
    await this.subscriber.subscribe(this.pubSubChannel);

    // Set up message handling with error protection
    this.subscriber.on('message', (_, message) => {
      // Skip message processing if instance has been stopped
      if (this.stopped) return;

      try {
        // Parse and process the incoming event
        const event: DiscoveryEvent = JSON.parse(message);
        handler(event);
      } catch (error) {
        // Log parsing or handler errors without breaking the subscription
        console.error('Error processing Redis event:', error);
      }
    });
  }

  /**
   * Removes a node from the service discovery system and cleans up all associated data.
   * This method performs an atomic transaction to ensure consistent removal of all
   * node-related data from Redis.
   * 
   * @param {string} nodeId - The unique identifier of the node to deregister
   * @returns {Promise<void>} A promise that resolves when the deregistration is complete
   * 
   * @remarks
   * The deregistration process:
   * 1. Removes the node's metadata from the nodes hash
   * 2. Deletes the node's heartbeat key
   * 3. Removes the node ID from the global node index
   * 
   * All operations are performed within a single Redis transaction to maintain consistency.
   */
  private async deregisterNodeById(nodeId: string): Promise<void> {
    const nodeKey = `netron:discovery:nodes:${nodeId}`;
    const heartbeatKey = `netron:discovery:heartbeat:${nodeId}`;

    const maxRetries = 3;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        await this.redis
          .multi()
          .del(nodeKey, heartbeatKey)
          .srem('netron:discovery:index:nodes', nodeId)
          .exec();

        if (attempt > 1) {
          console.info(`Deregistration of node '${nodeId}' succeeded after ${attempt} attempts`);
        }

        await this.publishEvent('NODE_DEREGISTERED');
        return;
      } catch (error) {
        console.error(`Deregistration attempt ${attempt} for node '${nodeId}' failed`, { error });

        if (attempt === maxRetries) {
          console.error(`All ${maxRetries} deregistration attempts for node '${nodeId}' failed.`);
          throw error;
        }

        await new Promise((res) => setTimeout(res, 500 * attempt));
      }
    }
  }

  /**
   * Verifies the current status of a specific node in the discovery system.
   * This method checks the node's heartbeat and automatically cleans up
   * the node's data if it's found to be inactive.
   * 
   * @param {string} nodeId - The unique identifier of the node to check
   * @returns {Promise<boolean>} A promise that resolves to true if the node is active,
   *                            false if the node is inactive or has been deregistered
   * 
   * @remarks
   * The check process:
   * 1. Verifies the existence of the node's heartbeat key
   * 2. If the heartbeat is missing, triggers automatic deregistration
   * 3. Returns the node's active status
   */
  public async isNodeActive(nodeId: string): Promise<boolean> {
    try {
      const heartbeatKey = `netron:discovery:heartbeat:${nodeId}`;
      const exists = await this.redis.exists(heartbeatKey);
      if (!exists) {
        await this.deregisterNodeById(nodeId);
      }
      return exists === 1;
    } catch (error) {
      console.error(`Error checking if node '${nodeId}' is active`, { error });
      throw error;
    }
  }

  /**
   * Updates the service registry for the current node.
   * This method updates the local service list and immediately publishes
   * the changes to the discovery system.
   * 
   * @param {ServiceInfo[]} services - An array of ServiceInfo objects representing
   *                                  the updated list of services provided by this node
   * @returns {Promise<void>} A promise that resolves when the update is complete
   * 
   * @remarks
   * The update process:
   * 1. Updates the local service registry
   * 2. Triggers an immediate heartbeat to propagate the changes
   * 3. Ensures other nodes in the network receive the updated service information
   */
  public async updateServices(services: ServiceInfo[]): Promise<void> {
    if (this.stopped) {
      console.warn(`Attempted to update services after shutdown initiated for node '${this.nodeId}'`);
      return;
    }
    this.services = services;
    try {
      await this.publishHeartbeat();
    } catch (error) {
      console.error(`Error updating services`, { error });
      throw error;
    }
  }

  /**
   * Updates the network address of the current node.
   * This method changes the node's address and immediately notifies
   * the discovery system of the change.
   * 
   * @param {string} address - The new network address where this node can be reached
   * @returns {Promise<void>} A promise that resolves when the update is complete
   * 
   * @remarks
   * The update process:
   * 1. Updates the local address
   * 2. Triggers an immediate heartbeat to propagate the change
   * 3. Ensures other nodes in the network receive the updated address information
   */
  public async updateAddress(address: string): Promise<void> {
    if (this.stopped) {
      console.warn(`Attempted to update address after shutdown initiated for node '${this.nodeId}'`);
      return;
    }
    this.address = address;
    try {
      await this.publishHeartbeat();
    } catch (error) {
      console.error(`Error updating address to '${address}'`, { error });
      throw error;
    }
  }

  /**
   * Publishes a service discovery event to the Redis PubSub channel.
   * This method is responsible for broadcasting node state changes to all
   * subscribers in the distributed system.
   * 
   * @param {('NODE_REGISTERED' | 'NODE_UPDATED' | 'NODE_DEREGISTERED')} type - The type of event being published
   * @returns {Promise<void>} A promise that resolves when the event has been published
   * 
   * @private
   * 
   * @remarks
   * The event payload includes:
   * - Event type indicating the nature of the change
   * - Node identifier for tracking the source
   * - Current network address of the node
   * - Array of services provided by the node
   * - Timestamp of the event for temporal ordering
   * 
   * @throws {Error} If Redis publish operation fails
   * 
   * @example
   * // Publishing a node registration event
   * await publishEvent('NODE_REGISTERED');
   */
  private async publishEvent(type: 'NODE_REGISTERED' | 'NODE_UPDATED' | 'NODE_DEREGISTERED'): Promise<void> {
    // Skip event publishing if PubSub functionality is disabled
    if (!this.options.pubSubEnabled) return;

    // Construct the event payload with current node state
    const eventPayload = {
      type,
      nodeId: this.nodeId,
      address: this.address,
      services: this.services,
      timestamp: Date.now(),
    };

    // Publish the event to the configured Redis PubSub channel
    await this.redis.publish(this.pubSubChannel, JSON.stringify(eventPayload));
  }

  /**
   * Unsubscribes from Redis PubSub events and cleans up the subscriber instance.
   * This method is part of the graceful shutdown process and ensures proper cleanup
   * of Redis PubSub resources.
   * 
   * @returns {Promise<void>} A promise that resolves when the unsubscribe operation is complete
   * 
   * @private
   * 
   * @remarks
   * The method performs the following operations in sequence:
   * 1. Checks if a subscriber instance exists
   * 2. Unsubscribes from the configured PubSub channel
   * 3. Disconnects the Redis subscriber client
   * 4. Clears the subscriber reference to allow garbage collection
   * 
   * @throws {Error} If Redis unsubscribe or disconnect operations fail
   * 
   * @example
   * // Unsubscribing from events during shutdown
   * await unsubscribeFromEvents();
   */
  private async unsubscribeFromEvents(): Promise<void> {
    if (this.subscriber) {
      await this.subscriber.unsubscribe(this.pubSubChannel);
      this.subscriber.disconnect();
      this.subscriber = undefined;
    }
  }
}

```

### File: src/service-discovery/types.ts
```
/**
 * Represents information about a network node in the service discovery system.
 * This interface encapsulates all essential metadata required to identify and connect to a node.
 * 
 * @interface NodeInfo
 * @property {string} nodeId - Unique identifier of the node within the network
 * @property {string} address - Network address where the node can be reached (e.g., "host:port")
 * @property {ServiceInfo[]} services - Array of services available on this node
 * @property {number} timestamp - Unix timestamp indicating when this node information was last updated
 */
export interface NodeInfo {
  nodeId: string;
  address: string;
  services: ServiceInfo[];
  timestamp: number;
}

/**
 * Describes a service available in the network.
 * This interface provides the basic identification information for a service.
 * 
 * @interface ServiceInfo
 * @property {string} name - Unique name of the service
 * @property {string} [version] - Optional version identifier of the service
 */
export interface ServiceInfo {
  name: string;
  version?: string;
}

/**
 * Configuration options for the service discovery mechanism.
 * These parameters control the behavior of the heartbeat system and event propagation
 * within the distributed service discovery system.
 * 
 * @interface DiscoveryOptions
 * @property {number} [heartbeatInterval] - Time interval in milliseconds between consecutive heartbeat messages.
 *                                         This determines how frequently a node announces its presence to the network.
 *                                         Lower values increase network traffic but improve failure detection speed.
 * @property {number} [heartbeatTTL] - Time-to-live in milliseconds for heartbeat records in the discovery system.
 *                                    This defines how long a node's heartbeat remains valid before being considered stale.
 *                                    Should be greater than heartbeatInterval to allow for network delays.
 * @property {boolean} [pubSubEnabled] - Enables or disables Redis Pub/Sub event broadcasting functionality.
 *                                      When enabled, the system will publish node registration, update, and
 *                                      deregistration events to subscribed clients.
 * @property {string} [pubSubChannel] - Redis Pub/Sub channel name for service discovery events.
 *                                     Defaults to 'netron:discovery:events' if not specified.
 *                                     All nodes in the network should use the same channel for proper event propagation.
 */
export interface DiscoveryOptions {
  heartbeatInterval?: number;
  heartbeatTTL?: number;
  pubSubEnabled?: boolean;
  pubSubChannel?: string;
}
/**
 * Represents an event that occurs within the service discovery system.
 * This interface defines the structure of events that are published when nodes
 * register, update their status, or deregister from the network.
 * 
 * @interface DiscoveryEvent
 * @property {'NODE_REGISTERED' | 'NODE_UPDATED' | 'NODE_DEREGISTERED'} type - The type of discovery event.
 *                                                                           NODE_REGISTERED: A new node has joined the network.
 *                                                                           NODE_UPDATED: An existing node has updated its information.
 *                                                                           NODE_DEREGISTERED: A node has left the network.
 * @property {string} nodeId - The unique identifier of the node associated with this event.
 * @property {string} address - The network address where the node can be reached (e.g., "host:port").
 * @property {ServiceInfo[]} services - An array of services that are available on the node at the time of the event.
 * @property {number} timestamp - Unix timestamp indicating when this event occurred.
 *                               Used for event ordering and determining event freshness.
 */
export interface DiscoveryEvent {
  type: 'NODE_REGISTERED' | 'NODE_UPDATED' | 'NODE_DEREGISTERED';
  nodeId: string;
  address: string;
  services: ServiceInfo[];
  timestamp: number;
}
```

### File: src/service-stub.ts
```
import { LocalPeer } from './local-peer';
import { Definition } from './definition';
import { ServiceMetadata } from './types';
import { StreamReference } from './stream-reference';
import { isNetronStream, isNetronService, isServiceReference, isServiceInterface, isServiceDefinition, isNetronStreamReference } from './predicates';

/**
 * ServiceStub представляет собой прокси-объект для экземпляра сервиса в системе Netron.
 * Этот класс обеспечивает прозрачное взаимодействие с удаленными сервисами, 
 * обрабатывая преобразование данных и управляя жизненным циклом сервисных определений.
 * 
 * @class ServiceStub
 * @description Основной класс для работы с сервисами в распределенной системе Netron
 */
export class ServiceStub {
  /** Определение сервиса, содержащее метаданные и спецификацию интерфейса */
  public definition: Definition;

  /**
   * Создает новый экземпляр ServiceStub.
   * 
   * @param {LocalPeer} peer - Локальный пир, с которым ассоциирован данный сервис
   * @param {any} instance - Экземпляр сервиса, который представляет данный заглушка
   * @param {ServiceMetadata | Definition} metaOrDefinition - Метаданные сервиса или готовое определение
   * @throws {Error} Если не удается создать определение сервиса
   */
  constructor(
    public peer: LocalPeer,
    public instance: any,
    metaOrDefinition: ServiceMetadata | Definition
  ) {
    if (isServiceDefinition(metaOrDefinition)) {
      this.definition = metaOrDefinition;
    } else {
      this.definition = new Definition(Definition.nextId(), peer.id, metaOrDefinition);
    }
  }

  /**
   * Устанавливает значение свойства сервиса.
   * 
   * @param {string} prop - Имя свойства для установки
   * @param {any} value - Значение для установки
   * @returns {void}
   * @throws {Error} Если свойство не существует или недоступно для записи
   */
  set(prop: string, value: any) {
    Reflect.set(this.instance, prop, this.processValue(value));
  }

  /**
   * Получает значение свойства сервиса.
   * 
   * @param {string} prop - Имя свойства для получения
   * @returns {any} Обработанное значение свойства
   * @throws {Error} Если свойство не существует или недоступно для чтения
   */
  get(prop: string) {
    return this.processResult(this.instance[prop]);
  }

  /**
   * Вызывает метод сервиса с заданными аргументами.
   * 
   * @param {string} method - Имя метода для вызова
   * @param {any[]} args - Аргументы для передачи в метод
   * @returns {Promise<any>} Обработанный результат вызова метода
   * @throws {Error} Если метод не существует или вызов завершился с ошибкой
   */
  async call(method: string, args: any[]) {
    const processedArgs = this.processArgs(args);
    let result = this.instance[method](...processedArgs);
    if (result instanceof Promise) {
      result = await result;
    }
    return this.processResult(result);
  }

  /**
   * Обрабатывает результат взаимодействия с сервисом.
   * Преобразует специальные типы данных (сервисы, потоки) в соответствующие ссылки.
   * 
   * @param {any} result - Результат для обработки
   * @returns {any} Обработанный результат
   * @private
   */
  private processResult(result: any) {
    if (isNetronService(result) || isServiceInterface(result)) {
      return this.peer.refService(result, this.definition);
    } else if (isNetronStream(result)) {
      return StreamReference.from(result);
    }
    return result;
  }

  /**
   * Обрабатывает массив аргументов для вызова метода.
   * Преобразует каждый аргумент в соответствии с его типом.
   * 
   * @param {any[]} args - Аргументы для обработки
   * @returns {any[]} Обработанные аргументы
   * @private
   */
  private processArgs(args: any[]) {
    return args.map((arg: any) => this.processValue(arg));
  }

  /**
   * Обрабатывает отдельное значение.
   * Преобразует ссылки на сервисы и потоки в соответствующие объекты.
   * 
   * @param {any} obj - Значение для обработки
   * @returns {any} Обработанное значение
   * @private
   */
  private processValue(obj: any) {
    if (isServiceReference(obj)) {
      return this.peer.queryInterfaceByDefId(obj.defId);
    } else if (isNetronStreamReference(obj)) {
      return StreamReference.to(obj, this.peer.netron.peers.get(obj.peerId)!);
    }
    return obj;
  }
}

```

### File: src/stream-reference.ts
```
import { RemotePeer } from "./remote-peer";
import { NetronReadableStream } from "./readable-stream";
import { NetronWritableStream } from "./writable-stream";

/**
 * Represents the type of stream that can be referenced.
 * This type is used to distinguish between readable and writable streams
 * in the Netron distributed system.
 * 
 * @typedef {('readable' | 'writable')} StreamType
 */
export type StreamType = 'readable' | 'writable';

/**
 * StreamReference is a serializable representation of a stream in the Netron system.
 * This class serves as a bridge between local stream instances and their remote
 * representations, enabling stream data to be transmitted across the network.
 * 
 * @class StreamReference
 * @property {number} streamId - Unique identifier of the stream
 * @property {StreamType} type - Type of the stream (readable or writable)
 * @property {boolean} isLive - Indicates if the stream is live/real-time
 * @property {string} peerId - ID of the peer that owns the stream
 */
export class StreamReference {
  /**
   * Creates a new StreamReference instance.
   * 
   * @param {number} streamId - Unique identifier of the stream
   * @param {StreamType} type - Type of the stream (readable or writable)
   * @param {boolean} isLive - Indicates if the stream is live/real-time
   * @param {string} peerId - ID of the peer that owns the stream
   */
  constructor(
    public readonly streamId: number,
    public readonly type: StreamType,
    public readonly isLive: boolean,
    public readonly peerId: string,
  ) { }

  /**
   * Creates a StreamReference from an existing stream instance.
   * This method is used to serialize a local stream for transmission over the network.
   * 
   * @static
   * @param {NetronReadableStream | NetronWritableStream} stream - The stream instance to reference
   * @returns {StreamReference} A new StreamReference representing the given stream
   */
  static from(stream: NetronReadableStream | NetronWritableStream): StreamReference {
    return new StreamReference(
      stream.id,
      stream instanceof NetronWritableStream ? 'writable' : 'readable',
      stream.isLive,
      stream.peer.id
    );
  }

  /**
   * Creates a stream instance from a StreamReference.
   * This method is used to deserialize a stream reference into a working stream instance
   * on the receiving end of a network transmission.
   * 
   * @static
   * @param {StreamReference} ref - The stream reference to convert
   * @param {RemotePeer} peer - The remote peer that owns the stream
   * @returns {NetronReadableStream | NetronWritableStream} A new stream instance
   * @throws {Error} If the stream type is invalid or creation fails
   */
  static to(ref: StreamReference, peer: RemotePeer): NetronReadableStream | NetronWritableStream {
    if (ref.type === 'writable') {
      return NetronReadableStream.create(peer, ref.streamId, ref.isLive);
    } else {
      return NetronWritableStream.create(peer, undefined, ref.isLive, ref.streamId);
    }
  }
}

```

### File: src/task-manager.ts
```
import { pathToFileURL } from 'url';
import { readdir } from 'fs/promises';

/**
 * Represents a task function that can be either synchronous or asynchronous.
 * Tasks are the fundamental units of work in the TaskManager system.
 * 
 * @typedef {(...args: any[]) => Promise<any> | any} Task
 * @description A function that can be executed by the TaskManager, supporting both
 * synchronous and asynchronous operations with variable arguments and return types.
 */
export type Task = (...args: any[]) => Promise<any> | any;

/**
 * Manages the lifecycle and execution of tasks within the Netron system.
 * This class provides a robust framework for registering, loading, and executing
 * tasks with configurable timeout and conflict resolution strategies.
 * 
 * @class TaskManager
 * @description Central task management system for handling both synchronous and
 * asynchronous operations with proper error handling and timeout mechanisms.
 */
export class TaskManager {
  /**
   * Internal storage for registered tasks.
   * Maps task names to their corresponding function implementations.
   * 
   * @private
   * @type {Map<string, Task>}
   */
  private tasks: Map<string, Task> = new Map();

  /**
   * Maximum execution time in milliseconds before a task is considered timed out.
   * 
   * @private
   * @type {number}
   */
  private timeout: number;

  /**
   * Strategy for handling task registration conflicts.
   * 
   * @private
   * @type {'replace' | 'skip' | 'throw'}
   * @description Determines behavior when registering a task with an existing name:
   * - 'replace': Overwrites the existing task
   * - 'skip': Preserves the existing task
   * - 'throw': Raises an error
   */
  private overwriteStrategy: 'replace' | 'skip' | 'throw';

  /**
   * Creates a new TaskManager instance with configurable parameters.
   * 
   * @constructor
   * @param {Object} options - Configuration options for the TaskManager
   * @param {number} [options.timeout=5000] - Default timeout in milliseconds
   * @param {'replace' | 'skip' | 'throw'} [options.overwriteStrategy='replace'] - Strategy for handling task conflicts
   */
  constructor({
    timeout = 5000,
    overwriteStrategy = 'replace',
  }: { timeout?: number; overwriteStrategy?: 'replace' | 'skip' | 'throw' } = {}) {
    this.timeout = timeout;
    this.overwriteStrategy = overwriteStrategy;
  }

  /**
   * Registers a new task with the TaskManager.
   * Validates the task function and handles registration according to the configured strategy.
   * 
   * @param {Task} fn - The task function to register
   * @throws {Error} If the provided argument is not a function
   * @throws {Error} If the function has no name
   * @throws {Error} If a task with the same name exists and overwriteStrategy is 'throw'
   */
  addTask(fn: Task) {
    if (typeof fn !== 'function') {
      throw new Error('Task must be a function');
    }
    if (!fn.name) {
      throw new Error('Task function must have a name');
    }

    const existingTask = this.tasks.get(fn.name);
    if (existingTask) {
      switch (this.overwriteStrategy) {
        case 'replace':
          this.tasks.set(fn.name, fn);
          break;
        case 'skip':
          return;
        case 'throw':
          throw new Error(`Task already exists: ${fn.name}`);
        default:
          throw new Error(`Unknown overwrite strategy: ${this.overwriteStrategy}`);
      }
    } else {
      this.tasks.set(fn.name, fn);
    }
  }

  /**
   * Loads tasks from JavaScript files in the specified directory.
   * Supports both CommonJS and ES modules through dynamic import.
   * 
   * @param {string} directory - Path to the directory containing task files
   * @throws {Error} If directory access or module loading fails
   */
  async loadTasksFromDir(directory: string) {
    try {
      const files = (await readdir(directory)).filter((f) => f.endsWith('.js'));

      for (const file of files) {
        let fileUrl = `${directory}/${file}`;
        if (typeof require !== 'function') {
          fileUrl = pathToFileURL(`${directory}/${file}`).href;
        }
        const module = await import(fileUrl);
        this._registerModule(module);
      }
    } catch (error: any) {
      throw new Error(`Failed to load tasks from directory (${directory}): ${error.message || error}`);
    }
  }

  /**
   * Executes a registered task with the provided arguments.
   * Implements timeout handling and proper cleanup of resources.
   * 
   * @param {string} name - Name of the task to execute
   * @param {...any} args - Arguments to pass to the task
   * @returns {Promise<any>} Result of the task execution
   * @throws {Error} If the task is not found
   * @throws {Error} If the task execution times out
   * @throws {Error} If the task execution fails
   */
  async runTask(name: string, ...args: any[]): Promise<any> {
    const task = this.tasks.get(name);
    if (!task) {
      throw new Error(`Task not found: ${name}`);
    }

    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`Task timed out: ${name} (${this.timeout}ms)`));
      }, this.timeout);

      try {
        const result = task(...args);
        if (result instanceof Promise) {
          result
            .then(resolve)
            .catch(reject)
            .finally(() => clearTimeout(timer));
        } else {
          clearTimeout(timer);
          resolve(result);
        }
      } catch (error) {
        clearTimeout(timer);
        reject(error);
      }
    });
  }

  /**
   * Registers all functions exported by a module as tasks.
   * 
   * @private
   * @param {Record<string, unknown>} module - The module containing task functions
   */
  private _registerModule(module: Record<string, unknown>) {
    for (const [name, fn] of Object.entries(module)) {
      if (typeof fn === 'function') {
        this.addTask(fn as Task);
      }
    }
  }
}

```

### File: src/types.ts
```
import { Definition } from './definition';

/**
 * Represents the capabilities and configuration of a remote peer.
 * This type defines what services and features are available on a remote peer.
 */
export type Abilities = {
  /**
   * Map of service names to their definitions that are exposed by the remote peer.
   * The key is the qualified service name (name:version) and the value is the service definition.
   */
  services?: Map<string, Definition>;

  /**
   * Indicates whether the remote peer should subscribe to service events.
   * When true, the peer will receive notifications about service exposure and unexposure.
   */
  allowServiceEvents?: boolean;
};

/**
 * Configuration options for creating a Netron instance.
 * These options control various aspects of the Netron instance's behavior.
 */
export type NetronOptions = {
  /**
   * Unique identifier for the Netron instance.
   * If not provided, a random UUID will be generated.
   */
  id?: string;

  /**
   * Host address to listen on for incoming connections (server only).
   * Defaults to 'localhost' if not specified.
   */
  listenHost?: string;

  /**
   * Port number to listen on for incoming connections (server only).
   * Required for server mode.
   */
  listenPort?: number;

  /**
   * Timeout in milliseconds for task execution.
   * Defaults to 5000ms if not specified.
   */
  taskTimeout?: number;

  /**
   * Strategy for handling duplicate tasks.
   * - 'replace': Replace existing task with new one
   * - 'skip': Keep existing task and skip new one
   * - 'throw': Throw an error if task already exists
   */
  taskOverwriteStrategy?: 'replace' | 'skip' | 'throw';

  /**
   * Timeout in milliseconds for establishing connections.
   * Defaults to 5000ms if not specified.
   */
  connectTimeout?: number;

  /**
   * Timeout in milliseconds for request operations.
   * Defaults to 5000ms if not specified.
   */
  requestTimeout?: number;

  /**
   * Timeout in milliseconds for stream operations.
   * Defaults to 5000ms if not specified.
   */
  streamTimeout?: number;

  /**
   * Whether to enable service events.
   * When true, events will be emitted when services are exposed or unexposed.
   */
  allowServiceEvents?: boolean;

  /**
   * Maximum number of reconnection attempts.
   * If not set, unlimited reconnection attempts will be made.
   */
  maxReconnectAttempts?: number;

  /**
   * Enable service discovery via Redis
   */
  discoveryEnabled?: boolean;

  /**
   * Redis connection string for service discovery
   */
  discoveryRedisUrl?: string;

  /**
   * Interval (ms) between heartbeats for service discovery
   */
  discoveryHeartbeatInterval?: number;

  /**
   * TTL (ms) for heartbeat keys in Redis
   */
  discoveryHeartbeatTTL?: number;

  /**
   * Enables or disables Redis Pub/Sub functionality for service discovery events.
   * When enabled, the system will publish real-time notifications about:
   * - Node registration events
   * - Service availability changes
   * - Node health status updates
   * - Network topology changes
   * 
   * This feature is particularly useful for:
   * - Building reactive systems that need immediate awareness of service changes
   * - Implementing dynamic load balancing
   * - Creating real-time monitoring dashboards
   * - Enabling automatic failover mechanisms
   * 
   * @default true
   * @type {boolean}
   * @see DiscoveryOptions
   * @see ServiceDiscovery
   */
  discoveryPubSubEnabled?: boolean;
};

/**
 * Type definition for event subscriber functions.
 * These functions are called when events are emitted.
 */
export type EventSubscriber = (...args: any[]) => void;

/**
 * Interface representing information about a method argument.
 * This metadata is used for type checking and documentation.
 */
export interface ArgumentInfo {
  /**
   * The zero-based index of the argument in the method signature.
   */
  index: number;

  /**
   * The type of the argument as a string.
   * This can be a primitive type, class name, or interface name.
   */
  type: string;
}

/**
 * Interface representing information about a method.
 * This metadata describes the method's return type and arguments.
 */
export interface MethodInfo {
  /**
   * The return type of the method as a string.
   * This can be a primitive type, class name, or interface name.
   */
  type: string;

  /**
   * Array of argument information objects.
   * Each object describes an argument's position and type.
   */
  arguments: ArgumentInfo[];
}

/**
 * Interface representing information about a property.
 * This metadata describes the property's type and mutability.
 */
export interface PropertyInfo {
  /**
   * The type of the property as a string.
   * This can be a primitive type, class name, or interface name.
   */
  type: string;

  /**
   * Whether the property is read-only.
   * If true, attempts to modify the property will result in an error.
   */
  readonly: boolean;
}

/**
 * Interface representing metadata for a service.
 * This metadata describes the service's name, version, properties, and methods.
 */
export interface ServiceMetadata {
  /**
   * The name of the service.
   * Must be a valid identifier containing only alphanumeric characters and dots.
   */
  name: string;

  /**
   * The version of the service.
   * Must follow semantic versioning (semver) format if specified.
   */
  version: string;

  /**
   * Map of property names to their metadata.
   * Only public properties are included in this map.
   */
  properties: Record<string, PropertyInfo>;

  /**
   * Map of method names to their metadata.
   * Only public methods are included in this map.
   */
  methods: Record<string, MethodInfo>;
}

/**
 * Event type emitted when a service is exposed.
 * Contains information about the exposed service and the peers involved.
 */
export type ServiceExposeEvent = {
  /**
   * The name of the exposed service.
   */
  name: string;

  /**
   * The version of the exposed service.
   */
  version: string;

  /**
   * The qualified name of the service (name:version).
   */
  qualifiedName: string;

  /**
   * The ID of the peer exposing the service.
   */
  peerId: string;

  /**
   * The ID of the remote peer, if applicable.
   */
  remotePeerId?: string;

  /**
   * The service definition object.
   */
  definition: Definition;
};

/**
 * Event type emitted when a service is unexposed.
 * Contains information about the unexposed service and the peers involved.
 */
export type ServiceUnexposeEvent = {
  /**
   * The name of the unexposed service.
   */
  name: string;

  /**
   * The version of the unexposed service.
   */
  version: string;

  /**
   * The qualified name of the service (name:version).
   */
  qualifiedName: string;

  /**
   * The ID of the peer unexposing the service.
   */
  peerId: string;

  /**
   * The ID of the remote peer, if applicable.
   */
  remotePeerId?: string;

  /**
   * The ID of the service definition.
   */
  defId: string;
};

/**
 * Event type emitted when a peer connects.
 * Contains information about the connected peer.
 */
export type PeerConnectEvent = {
  /**
   * The ID of the connected peer.
   */
  peerId: string;
};

/**
 * Event type emitted when a peer disconnects.
 * Contains information about the disconnected peer.
 */
export type PeerDisconnectEvent = {
  /**
   * The ID of the disconnected peer.
   */
  peerId: string;
};

```

### File: src/uid.ts
```
import { MAX_UID_VALUE } from './constants';

/**
 * A class that provides functionality for generating and managing unique identifiers (UIDs)
 * within the Netron system. This implementation ensures thread-safe and sequential
 * generation of unique identifiers while maintaining a strict upper bound.
 * 
 * @class Uid
 * @description Core identifier generation system for packet tracking and correlation
 * @property {number} value - Current UID value, stored as an unsigned 32-bit integer
 */
export class Uid {
  /**
   * Current UID value, stored as an unsigned 32-bit integer.
   * The value is initialized using a zero-fill right shift to ensure proper
   * unsigned integer representation.
   * 
   * @private
   * @type {number}
   */
  private value: number = 0 >>> 0;

  /**
   * Creates a new Uid instance with an optional initial value.
   * The constructor ensures proper initialization by calling reset() with
   * the provided initial value.
   * 
   * @constructor
   * @param {number} [initialValue=0] - The starting value for UID generation
   */
  constructor(initialValue: number = 0) {
    this.reset(initialValue);
  }

  /**
   * Generates the next unique identifier in sequence.
   * This method implements a circular counter that wraps around to 1 when
   * reaching MAX_UID_VALUE, ensuring continuous unique identifier generation
   * within the defined bounds.
   * 
   * @method next
   * @returns {number} The next unique identifier in sequence
   * @throws {Error} If the maximum UID value is exceeded
   */
  next(): number {
    this.value = this.value === MAX_UID_VALUE ? 1 : this.value + 1;
    return this.value;
  }

  /**
   * Resets the UID generator to a specified initial value.
   * The value is converted to an unsigned 32-bit integer using a zero-fill
   * right shift operation to ensure proper numeric representation.
   * 
   * @method reset
   * @param {number} [initialValue=0] - The value to reset the generator to
   * @throws {Error} If the initial value exceeds MAX_UID_VALUE
   */
  reset(initialValue: number = 0) {
    this.value = initialValue >>> 0;
  }
}

```

### File: src/utils.ts
```
import { ServiceMetadata } from './types';
import { SERVICE_ANNOTATION } from './constants';

/**
 * Generates a standardized event name for service-related events.
 * This function creates a predictable naming pattern for service events
 * by prefixing the service name with 'svc:'.
 * 
 * @param {string} serviceName - The name of the service to generate an event name for
 * @returns {string} A formatted event name in the format 'svc:serviceName'
 * @example
 * getServiceEventName('auth') // returns 'svc:auth'
 */
export const getServiceEventName = (serviceName: string) => `svc:${serviceName}`;

/**
 * Generates a standardized event name for peer-related events.
 * This function creates a predictable naming pattern for peer events
 * by prefixing the peer ID with 'peer:'.
 * 
 * @param {string} peerId - The unique identifier of the peer
 * @returns {string} A formatted event name in the format 'peer:peerId'
 * @example
 * getPeerEventName('peer-123') // returns 'peer:peer-123'
 */
export const getPeerEventName = (peerId: string) => `peer:${peerId}`;

/**
 * Retrieves the service metadata associated with a service instance.
 * This function uses reflection to access metadata that was previously
 * attached to the service's constructor using decorators.
 * 
 * @param {any} instance - The service instance to retrieve metadata for
 * @returns {ServiceMetadata} The metadata associated with the service
 * @throws {Error} If the metadata cannot be retrieved or is invalid
 */
export const getServiceMetadata = (instance: any) =>
  Reflect.getMetadata(SERVICE_ANNOTATION, instance.constructor) as ServiceMetadata;

/**
 * Constructs a qualified name by combining a base name with an optional version.
 * This function is used to create unique identifiers for services and other
 * components that support versioning.
 * 
 * @param {string} name - The base name to qualify
 * @param {string} [version] - Optional version string to append
 * @returns {string} A qualified name in the format 'name' or 'name@version'
 * @example
 * getQualifiedName('auth', '1.0.0') // returns 'auth@1.0.0'
 * getQualifiedName('auth') // returns 'auth'
 */
export const getQualifiedName = (name: string, version?: string) => `${name}${version ? `@${version}` : ''}`;

```

### File: src/writable-stream.ts
```
import { Writable, Readable, WritableOptions } from 'stream';

import { Uid } from './uid';
import { RemotePeer } from './remote-peer';
import { Packet, createPacket, TYPE_STREAM_ERROR } from './packet';

/**
 * Global UID generator instance for creating unique stream identifiers.
 * This ensures that each stream gets a unique ID across the application.
 */
const uid = new Uid();

/**
 * Configuration options for creating a NetronWritableStream instance.
 * Extends Node.js WritableOptions with Netron-specific properties.
 * 
 * @interface NetronWritableStreamOptions
 * @extends {WritableOptions}
 * @property {RemotePeer} peer - The remote peer this stream is associated with
 * @property {number} [streamId] - Optional custom stream identifier
 * @property {boolean} [isLive] - Whether the stream is operating in live/real-time mode
 */
export interface NetronWritableStreamOptions extends WritableOptions {
  peer: RemotePeer;
  streamId?: number;
  isLive?: boolean;
}

/**
 * A specialized writable stream implementation for the Netron distributed system.
 * This class extends Node.js Writable stream to provide distributed stream capabilities
 * with proper error handling, cleanup, and remote peer communication.
 * 
 * @class NetronWritableStream
 * @extends {Writable}
 * @property {number} id - Unique identifier for this stream instance
 * @property {RemotePeer} peer - The remote peer this stream is associated with
 * @property {boolean} isLive - Indicates if the stream is operating in live mode
 */
export class NetronWritableStream extends Writable {
  /** Unique identifier for this stream instance */
  public readonly id: number;

  /** The remote peer this stream is associated with */
  public readonly peer: RemotePeer;

  /** Current chunk index for maintaining write order */
  private index: number = 0;

  /** Whether the stream is operating in live/real-time mode */
  public isLive: boolean;

  /** Flag indicating if the stream has been closed */
  private isClosed: boolean = false;

  /**
   * Creates a new NetronWritableStream instance.
   * 
   * @constructor
   * @param {NetronWritableStreamOptions} options - Configuration options for the stream
   * @param {RemotePeer} options.peer - The remote peer this stream is associated with
   * @param {number} [options.streamId] - Optional custom stream identifier
   * @param {boolean} [options.isLive=false] - Whether the stream is operating in live mode
   * @param {WritableOptions} [options] - Additional Node.js stream options
   */
  constructor({ peer, streamId, isLive = false, ...opts }: NetronWritableStreamOptions) {
    super({ ...opts, objectMode: true });

    this.peer = peer;
    this.isLive = isLive;
    this.id = streamId ?? uid.next();

    this.peer.writableStreams.set(this.id, this);

    this.once('close', this.cleanup);
    this.once('error', this.handleError);
  }

  /**
   * Pipes data from an AsyncIterable or Readable stream into this stream.
   * Handles backpressure and ensures proper cleanup on errors.
   * 
   * @param {AsyncIterable<any> | Readable} source - The source stream to pipe from
   * @returns {Promise<void>} A promise that resolves when piping is complete
   * @throws {Error} If an error occurs during the piping process
   */
  public async pipeFrom(source: AsyncIterable<any> | Readable): Promise<void> {
    try {
      for await (const chunk of source) {
        if (!this.write(chunk)) {
          await new Promise((resolve) => this.once('drain', resolve));
        }
      }
      this.end();
    } catch (error) {
      this.destroy(error instanceof Error ? error : new Error(String(error)));
    }
  }

  /**
   * Internal write implementation for handling stream chunks.
   * Sends data to the remote peer and manages stream state.
   * 
   * @override
   * @param {any} chunk - The data chunk to write
   * @param {BufferEncoding} _ - Unused encoding parameter
   * @param {(error?: Error | null) => void} callback - Callback to signal write completion
   */
  override _write(chunk: any, _: BufferEncoding, callback: (error?: Error | null) => void): void {
    if (this.isClosed) {
      callback(new Error('Stream is already closed'));
      return;
    }

    this.peer.sendStreamChunk(this.id, chunk, this.index++, false, this.isLive)
      .then(() => callback())
      .catch((err: Error) => {
        this.peer.sendPacket(createPacket(Packet.nextId(), 1, TYPE_STREAM_ERROR, {
          streamId: this.id,
          message: err.message,
        })).finally(() => {
          callback(err);
          this.destroy(err);
        });
      });
  }

  /**
   * Internal final implementation for handling stream completion.
   * Sends final chunk to remote peer and performs cleanup.
   * 
   * @override
   * @param {(error?: Error | null) => void} callback - Callback to signal finalization completion
   */
  override _final(callback: (error?: Error | null) => void): void {
    if (this.isClosed) {
      callback(new Error('Stream is already closed'));
      return;
    }

    this.peer.sendStreamChunk(this.id, null, this.index, true, this.isLive)
      .then(() => callback())
      .catch((err: Error) => {
        callback(err);
        this.destroy(err);
      })
      .finally(() => this.closeStream());
  }

  /**
   * Gracefully closes the stream and performs cleanup.
   * This method ensures proper resource cleanup and state management.
   */
  public closeStream(): void {
    if (this.isClosed) return;

    this.isClosed = true;
    this.end();
    this.cleanup();
  }

  /**
   * Overrides the destroy method to ensure proper cleanup and error handling.
   * Sends a final chunk to the remote peer before destruction.
   * 
   * @override
   * @param {Error} [error] - Optional error that caused the destruction
   * @returns {this} The stream instance for chaining
   */
  public override destroy(error?: Error): this {
    if (this.isClosed) return this;

    this.isClosed = true;

    this.peer.sendStreamChunk(this.id, null, this.index, true, this.isLive)
      .catch((sendError) => {
        console.error(`Failed to send final stream chunk:`, sendError);
      })
      .finally(() => {
        super.destroy(error);
        this.cleanup();
      });

    return this;
  }

  /**
   * Internal cleanup method that removes stream references from the peer.
   * This ensures proper garbage collection and prevents memory leaks.
   */
  private cleanup = () => {
    this.peer.writableStreams.delete(this.id);
  };

  /**
   * Error handler for stream errors.
   * Logs the error and performs cleanup operations.
   * 
   * @param {Error} err - The error that occurred
   */
  private handleError = (err: Error) => {
    console.error(`NetronWritableStream (id: ${this.id}) error:`, err.message);
    this.cleanup();
  };

  /**
   * Factory method for creating a NetronWritableStream instance.
   * Optionally pipes data from a source stream if provided.
   * 
   * @static
   * @param {RemotePeer} peer - The remote peer this stream is associated with
   * @param {AsyncIterable<any> | Readable} [source] - Optional source stream to pipe from
   * @param {boolean} [isLive=false] - Whether the stream is operating in live mode
   * @param {number} [streamId] - Optional custom stream identifier
   * @returns {NetronWritableStream} A new stream instance
   */
  public static create(peer: RemotePeer, source?: AsyncIterable<any> | Readable, isLive: boolean = false, streamId?: number): NetronWritableStream {
    const stream = new NetronWritableStream({ peer, streamId, isLive });

    if (source) {
      stream.pipeFrom(source);
    }

    return stream;
  }
}

```

